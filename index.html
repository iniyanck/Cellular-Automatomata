<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Automaton Engine V2</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --text: #f8fafc;
            --muted: #94a3b8;
            --border: #334155;
            --success: #22c55e;
            --danger: #ef4444;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* --- HEADER & GLOBAL CONTROLS --- */
        header {
            padding: 15px 20px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.2rem; color: var(--accent); letter-spacing: -0.5px; }

        .global-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.2);
            padding: 5px 10px;
            border-radius: 6px;
        }

        input[type="range"] {
            width: 100px;
            accent-color: var(--accent);
        }

        label { font-size: 0.8rem; color: var(--muted); text-transform: uppercase; font-weight: bold; }

        /* --- MAIN LAYOUT --- */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* --- LEFT: THE WORLD --- */
        .world-container {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #020617;
            position: relative;
        }

        #worldCanvas {
            image-rendering: pixelated;
            border: 1px solid var(--border);
            box-shadow: 0 0 50px rgba(99, 102, 241, 0.1);
            max-width: 100%;
            max-height: 80vh;
        }

        .world-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--muted);
            pointer-events: none;
        }

        /* --- RIGHT: THE LOGIC STACK --- */
        .logic-stack {
            width: 380px;
            background: var(--bg);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px;
        }

        .stack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        /* --- SUPER RULE CARD --- */
        .rule-card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
        }

        .rule-card:hover { border-color: var(--accent); }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .card-title { font-weight: 600; font-size: 0.9rem; color: var(--text); }
        
        .rule-body {
            display: flex;
            gap: 15px;
        }

        /* Physics Grid Area */
        .physics-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .physics-canvas {
            border: 1px solid var(--border);
            cursor: crosshair;
            background: #000;
        }

        /* Sub Rules Area */
        .sub-rules-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }

        .sub-rule-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.2);
            padding: 4px;
            border-radius: 4px;
        }

        .sub-canvas {
            border: 1px solid var(--border);
            cursor: pointer;
        }

        .mini-btn {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 0.8rem;
            padding: 2px;
        }
        .mini-btn:hover { color: var(--text); }

        /* --- BUTTONS --- */
        button {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--panel);
            color: var(--text);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.1s;
        }
        button:hover { background: var(--border); }
        button.primary { background: var(--accent); border-color: var(--accent); }
        button.primary:hover { background: var(--accent-hover); }
        button.danger { color: var(--danger); border-color: rgba(239, 68, 68, 0.3); }
        button.active { background: var(--success); border-color: var(--success); color: #000; font-weight: bold;}
        
        /* Utility */
        .btn-row { display: flex; gap: 5px; margin-top: 5px; }
        .hint { font-size: 0.7rem; color: var(--muted); margin-top: 2px; text-align: center; }

    </style>
</head>
<body>

    <header>
        <div style="display:flex; flex-direction:column;">
            <h1>Recursive Automaton v2</h1>
            <span style="font-size:0.7rem; color:var(--muted)">Manual Logic Injection Engine</span>
        </div>
        
        <div class="global-controls">
            <div class="control-group">
                <label>Speed</label>
                <input type="range" id="speedSlider" min="1" max="60" value="30">
                <span id="fpsDisplay" style="font-size: 0.8rem; width: 30px;">30</span>
            </div>
            <div class="control-group">
                <button id="globalPauseBtn" class="primary">Pause World</button>
                <button onclick="world.reset()">Clear World</button>
                <button onclick="world.randomize()">Rnd World</button>
            </div>
        </div>
    </header>

    <div class="workspace">
        <div class="world-container">
            <canvas id="worldCanvas" width="100" height="60"></canvas>
            <div class="world-overlay">
                Wrap: <span id="wrapStatus">ON</span>
            </div>
        </div>

        <div class="logic-stack">
            <div class="stack-header">
                <span>Logic Layers (Super Rules)</span>
                <button class="primary" onclick="addSuperRule()">+ Add Layer</button>
            </div>
            <div id="rulesContainer">
                </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const WORLD_W = 100;
        const WORLD_H = 60;
        const PHYS_SIZE = 9;
        const SUB_SIZE = 3;

        // --- CLASSES ---

        class Grid {
            constructor(w, h) {
                this.w = w;
                this.h = h;
                this.data = new Int8Array(w * h);
                this.next = new Int8Array(w * h);
            }

            clear() { this.data.fill(0); }
            
            randomize(density = 0.5) {
                for(let i=0; i<this.data.length; i++) 
                    this.data[i] = Math.random() < density ? 1 : 0;
            }

            get(x, y, wrap = true) {
                if (wrap) {
                    x = (x + this.w) % this.w;
                    y = (y + this.h) % this.h;
                } else {
                    if (x < 0 || x >= this.w || y < 0 || y >= this.h) return 0;
                }
                return this.data[y * this.w + x];
            }

            set(x, y, val) {
                if (x >= 0 && x < this.w && y >= 0 && y < this.h) {
                    this.data[y * this.w + x] = val;
                }
            }

            toggle(x, y) {
                let idx = y * this.w + x;
                if(idx >= 0 && idx < this.data.length) this.data[idx] ^= 1;
            }

            swap() {
                let temp = this.data;
                this.data = this.next;
                this.next = temp;
                this.next.fill(0); // Clean slate for next calculation
            }
        }

        class SubRule {
            constructor(parent) {
                this.grid = new Grid(SUB_SIZE, SUB_SIZE);
                this.grid.randomize(0.4);
                this.id = Math.random().toString(36).substr(2, 9);
            }
        }

        class SuperRule {
            constructor(id) {
                this.id = id;
                this.physics = new Grid(PHYS_SIZE, PHYS_SIZE);
                this.physics.randomize(0.3);
                this.subRules = [new SubRule(), new SubRule()]; // Start with 2 sub-rules
                this.paused = false;
                this.wrap = true;
            }

            // The Physics Step: Standard GoL logic + SubRule Injection
            step() {
                if (this.paused) return;

                const g = this.physics;
                
                // 1. Standard Cellular Automata Step
                for (let y = 0; y < g.h; y++) {
                    for (let x = 0; x < g.w; x++) {
                        let neighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                neighbors += g.get(x + dx, y + dy, this.wrap);
                            }
                        }
                        let self = g.get(x, y, this.wrap);
                        
                        // Default Conway Rules
                        if (self === 1 && (neighbors === 2 || neighbors === 3)) g.next[y*g.w+x] = 1;
                        else if (self === 0 && neighbors === 3) g.next[y*g.w+x] = 1;
                        else g.next[y*g.w+x] = 0;
                    }
                }

                // 2. Sub-Rule Injection (The DNA effect)
                // If a sub-rule pattern matches perfectly, force life around it?
                // Simpler: Just OR the SubRule into the Physics grid at random or fixed spots?
                // Let's do Convoluted Influence: If a 3x3 area matches a SubRule, spawn life in center.
                
                // We'll apply this to 'next' buffer
                this.subRules.forEach(sub => {
                    // check center of physics grid against this subrule?
                    // To keep performance high, let's just use SubRules as "stamps"
                    // Every tick, there is a small chance a SubRule gets "stamped" onto the physics grid
                    // This simulates "DNA mutation" or influence.
                    if(Math.random() < 0.1) {
                        let rx = Math.floor(Math.random() * (PHYS_SIZE - SUB_SIZE));
                        let ry = Math.floor(Math.random() * (PHYS_SIZE - SUB_SIZE));
                        for(let sy=0; sy<SUB_SIZE; sy++){
                            for(let sx=0; sx<SUB_SIZE; sx++){
                                if(sub.grid.get(sx,sy)) {
                                    let idx = (ry+sy)*g.w + (rx+sx);
                                    g.next[idx] = 1; 
                                }
                            }
                        }
                    }
                });

                g.swap();
            }

            // The Lookup Logic for the World
            // Maps (NeighborCount, SelfState) -> ResultState
            getResult(neighborCount, selfState) {
                // Map neighbor count (0-8) to Row (0-8)
                // Map self state (0 or 1) to Column (Center Left or Center Right)
                // Dead lookup: Col 3. Alive lookup: Col 5.
                let col = selfState ? 5 : 3;
                let row = neighborCount; // Safe as neighborCount is max 8, height is 9
                return this.physics.get(col, row, false); // No wrap on lookup
            }
        }

        class WorldSimulation {
            constructor() {
                this.grid = new Grid(WORLD_W, WORLD_H);
                this.grid.randomize(0.1); // Start sparse
                this.superRules = [];
                this.paused = false;
                this.wrap = true;
            }

            addRule() {
                this.superRules.push(new SuperRule(Date.now()));
                renderRulesUI();
            }

            removeRule(id) {
                this.superRules = this.superRules.filter(r => r.id !== id);
                renderRulesUI();
            }

            reset() { this.grid.clear(); }
            randomize() { this.grid.randomize(); }

            step() {
                if (this.paused) return;

                // Step 1: Evolve all Super Rules
                this.superRules.forEach(rule => rule.step());

                // Step 2: Evolve World based on Super Rules
                if (this.superRules.length === 0) return; // No physics = freeze

                const g = this.grid;
                
                for (let i = 0; i < g.data.length; i++) {
                    let x = i % g.w;
                    let y = Math.floor(i / g.w);

                    // Count Neighbors
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            neighbors += g.get(x + dx, y + dy, this.wrap);
                        }
                    }

                    let self = g.data[i];
                    let willLive = 0;

                    // CHECK ALL SUPER RULES (OR Logic)
                    // If ANY active physics engine says "Given this neighbor count, you live", then you live.
                    for (let r of this.superRules) {
                        if (r.getResult(neighbors, self) === 1) {
                            willLive = 1;
                            break; 
                        }
                    }
                    g.next[i] = willLive;
                }
                g.swap();
            }
        }

        // --- GLOBAL STATE ---
        const world = new WorldSimulation();
        // Add one initial rule
        world.addRule();

        // Canvas Contexts
        const worldCtx = document.getElementById('worldCanvas').getContext('2d');
        let fps = 30;
        let lastTime = 0;

        // --- RENDERERS ---

        function drawGrid(ctx, grid, w, h, color, scaleX, scaleY) {
            ctx.fillStyle = '#020617'; 
            ctx.fillRect(0,0, w*scaleX, h*scaleY); // Clear

            ctx.fillStyle = color;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (grid.data[y * w + x]) {
                        ctx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
                    }
                }
            }
            
            // Grid lines overlay (optional, subtle)
            // ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            // ctx.strokeRect(0,0, w*scaleX, h*scaleY);
        }

        function drawPhysicsGrid(ctx, rule) {
            const grid = rule.physics;
            const w = grid.w;
            const h = grid.h;
            const cw = ctx.canvas.width;
            const ch = ctx.canvas.height;
            const scaleX = cw / w;
            const scaleY = ch / h;

            drawGrid(ctx, grid, w, h, '#a855f7', scaleX, scaleY);

            // Highlight Lookup Columns (Visual Aid for User)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.fillRect(3 * scaleX, 0, scaleX, ch); // Column 3 (Dead Rule)
            ctx.fillRect(5 * scaleX, 0, scaleX, ch); // Column 5 (Alive Rule)
            
            // Text Labels
            ctx.font = '10px monospace';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('D', 3 * scaleX + 4, 10);
            ctx.fillText('A', 5 * scaleX + 4, 10);
        }

        function renderWorld() {
            const w = world.grid.w;
            const h = world.grid.h;
            const cw = worldCtx.canvas.width;
            const ch = worldCtx.canvas.height;
            // Native resolution drawing
            drawGrid(worldCtx, world.grid, w, h, '#6366f1', cw/w, ch/h);
        }

        // --- UI GENERATION ---
        
        function addSuperRule() { world.addRule(); }
        
        function renderRulesUI() {
            const container = document.getElementById('rulesContainer');
            container.innerHTML = '';

            world.superRules.forEach((rule, index) => {
                const card = document.createElement('div');
                card.className = 'rule-card';
                
                // Header
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">Layer ${index+1} (9x9 Physics)</div>
                        <div style="display:flex; gap:5px;">
                             <button class="${rule.paused ? 'active' : ''}" onclick="toggleRulePause(${rule.id})">
                                ${rule.paused ? 'EDIT' : 'RUN'}
                             </button>
                             <button class="danger" onclick="world.removeRule(${rule.id})">×</button>
                        </div>
                    </div>
                    <div class="rule-body">
                        <div class="physics-area">
                            <canvas id="phys-${rule.id}" class="physics-canvas" width="90" height="90"></canvas>
                            <div class="btn-row">
                                <button onclick="randomizeRule(${rule.id})">Rnd</button>
                                <button onclick="clearRule(${rule.id})">Clr</button>
                            </div>
                            <div class="hint">${rule.paused ? 'Click grid to Edit Logic' : 'Pause to Edit'}</div>
                        </div>
                        <div class="sub-rules-list" id="sub-${rule.id}">
                            <div style="font-size:0.75rem; color:#94a3b8; margin-bottom:4px;">Injected Sub-Rules</div>
                            <button class="secondary" style="width:100%; margin-top:auto;" onclick="addSubRule(${rule.id})">+ Pattern</button>
                        </div>
                    </div>
                `;
                container.appendChild(card);

                // Add Sub Rules
                const subContainer = document.getElementById(`sub-${rule.id}`);
                rule.subRules.forEach((sub, subIdx) => {
                    const item = document.createElement('div');
                    item.className = 'sub-rule-item';
                    
                    const can = document.createElement('canvas');
                    can.className = 'sub-canvas';
                    can.width = 30;
                    can.height = 30;
                    // Click to edit sub rule
                    can.onclick = () => {
                        sub.grid.randomize(); 
                    };
                    
                    // Initial draw of sub rule
                    const ctx = can.getContext('2d');
                    drawGrid(ctx, sub.grid, SUB_SIZE, SUB_SIZE, '#22c55e', 10, 10);
                    
                    // Re-draw loop handled by main loop? No, sub rules are static unless clicked.
                    // Let's hook the click to re-draw immediately.
                    can.addEventListener('mousedown', (e) => {
                        // Simple toggle for 3x3
                        const rect = can.getBoundingClientRect();
                        const x = Math.floor((e.clientX - rect.left) / 10);
                        const y = Math.floor((e.clientY - rect.top) / 10);
                        sub.grid.toggle(x,y);
                        drawGrid(ctx, sub.grid, SUB_SIZE, SUB_SIZE, '#22c55e', 10, 10);
                    });

                    item.appendChild(can);
                    item.innerHTML += `<div style="flex:1; font-size:0.7rem;">Click to Edit</div>`;
                    item.innerHTML += `<button class="mini-btn" onclick="removeSubRule(${rule.id}, '${sub.id}')">×</button>`;
                    
                    subContainer.insertBefore(item, subContainer.lastElementChild);
                });

                // Attach Physics Canvas Interaction
                const pCan = document.getElementById(`phys-${rule.id}`);
                pCan.addEventListener('mousedown', (e) => handlePhysClick(e, rule, pCan));
            });
        }

        // --- INTERACTION HANDLERS ---

        function toggleRulePause(id) {
            const rule = world.superRules.find(r => r.id === id);
            if(rule) {
                rule.paused = !rule.paused;
                renderRulesUI(); // Refresh button state
            }
        }

        function randomizeRule(id) {
            const rule = world.superRules.find(r => r.id === id);
            if(rule) rule.physics.randomize();
        }
        function clearRule(id) {
            const rule = world.superRules.find(r => r.id === id);
            if(rule) rule.physics.clear();
        }

        function handlePhysClick(e, rule, canvas) {
            // Allow drawing even if running, but it might be overwritten immediately if logic is aggressive
            // Best to draw when paused.
            const rect = canvas.getBoundingClientRect();
            const scale = canvas.width / PHYS_SIZE; // 90 / 9 = 10
            const x = Math.floor((e.clientX - rect.left) / scale);
            const y = Math.floor((e.clientY - rect.top) / scale);
            
            rule.physics.toggle(x, y);
        }

        function addSubRule(ruleId) {
            const rule = world.superRules.find(r => r.id === ruleId);
            if(rule) {
                rule.subRules.push(new SubRule());
                renderRulesUI();
            }
        }

        function removeSubRule(ruleId, subId) {
            const rule = world.superRules.find(r => r.id === ruleId);
            if(rule) {
                rule.subRules = rule.subRules.filter(s => s.id !== subId);
                renderRulesUI();
            }
        }

        // Global Controls
        const speedSlider = document.getElementById('speedSlider');
        const fpsDisplay = document.getElementById('fpsDisplay');
        speedSlider.addEventListener('input', (e) => {
            fps = parseInt(e.target.value);
            fpsDisplay.innerText = fps;
        });

        const pauseBtn = document.getElementById('globalPauseBtn');
        pauseBtn.addEventListener('click', () => {
            world.paused = !world.paused;
            pauseBtn.innerText = world.paused ? "Resume World" : "Pause World";
            pauseBtn.classList.toggle('active');
        });

        // --- MAIN LOOP ---

        function loop(timestamp) {
            if (timestamp - lastTime >= 1000 / fps) {
                // Logic Step
                world.step();
                lastTime = timestamp;
            }

            // Render Step (Always run to keep UI responsive)
            renderWorld();

            // Render Physics Grids
            world.superRules.forEach(rule => {
                const can = document.getElementById(`phys-${rule.id}`);
                if(can) {
                    drawPhysicsGrid(can.getContext('2d'), rule);
                }
            });

            requestAnimationFrame(loop);
        }

        // Start
        requestAnimationFrame(loop);

    </script>
</body>
</html>