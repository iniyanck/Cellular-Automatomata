<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolfram-Driven 2D Automaton v2.3 (Masked)</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #94a3b8;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);
            --border: #334155;
            --run: #10b981;
            --stop: #f43f5e;
            --warn: #f97316;
            --lock-on: #4ade80; /* Green for force ON */
            --lock-off: #ef4444; /* Red for force OFF */
        }

        body {
            font-family: 'Segoe UI', 'Roboto', monospace;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-size: 13px;
        }

        /* --- LAYOUT --- */
        .viewport {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            position: relative;
        }

        .controls {
            width: 400px;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
        }

        /* --- COMPONENTS --- */
        .header {
            padding: 15px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-block {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--panel);
        }

        h2 { margin: 0 0 12px 0; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: #cbd5e1; }
        
        button {
            background: #334155; border: 1px solid #475569; color: #e2e8f0;
            padding: 6px 12px; cursor: pointer; border-radius: 4px;
            font-family: inherit; transition: all 0.2s;
            font-size: 11px;
            text-transform: uppercase;
        }
        button:hover { background: #475569; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button.primary { background: var(--accent); border-color: var(--accent); color: white; }
        button.primary:hover { box-shadow: 0 0 10px var(--accent-glow); }
        
        button.danger { background: var(--stop); border-color: var(--stop); color: white; }
        
        button.lock-btn { border-color: var(--lock-on); color: var(--lock-on); background: transparent; }
        button.lock-btn:hover { background: rgba(74, 222, 128, 0.1); }

        input[type="range"] { width: 100%; cursor: pointer; }
        input[type="number"] {
            background: #0f172a; border: 1px solid #334155; color: white;
            padding: 4px; border-radius: 4px; width: 60px; font-family: monospace;
        }
        input[type="checkbox"] { cursor: pointer; }

        label { display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none; }

        /* --- CANVAS AREAS --- */
        .world-wrapper {
            flex: 1;
            background: #020617; /* Darker slate for less harsh contrast */
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: crosshair;
        }

        canvas#worldCanvas {
            image-rendering: pixelated;
            width: 100%; height: 100%; object-fit: contain;
        }

        .wolfram-display-container {
            position: relative;
            margin-top: 10px;
            border: 1px solid var(--border);
            cursor: ns-resize;
        }

        canvas#wolframCanvas {
            width: 100%; height: 80px;
            background: #020617;
            image-rendering: pixelated;
            display: block;
            cursor: crosshair;
        }

        /* --- INSPECTOR OVERLAY --- */
        .neighborhood-preview {
            position: absolute;
            bottom: 20px; left: 20px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--border);
            padding: 10px;
            border-radius: 6px;
            pointer-events: none;
            display: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }
        
        .nb-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;
            margin-bottom: 5px;
        }
        .nb-cell { width: 12px; height: 12px; background: #334155; }
        .nb-cell.on { background: #bae6fd; box-shadow: 0 0 4px #bae6fd; }
        .nb-cell.center { border: 1px solid var(--accent); }

        /* --- RULE BITS --- */
        .rule-grid {
            display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px;
            margin-top: 15px;
        }
        .rule-bit {
            display: flex; flex-direction: column; align-items: center;
            cursor: pointer; padding: 6px 2px;
            background: rgba(255,255,255,0.03); border: 1px solid transparent; border-radius: 4px;
        }
        .rule-bit:hover { background: rgba(255,255,255,0.1); }
        .rule-bit.active { border-color: var(--accent); background: rgba(99, 102, 241, 0.1); }
        
        .bit-pattern { display: flex; gap: 1px; margin-bottom: 6px; }
        .bit-cell { width: 4px; height: 4px; background: #475569; }
        .bit-cell.on { background: #e2e8f0; }
        
        .bit-val { font-size: 10px; color: #64748b; font-weight: bold; }
        .rule-bit.active .bit-val { color: var(--accent); }

        /* --- UTILS --- */
        .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .sub-text { font-size: 11px; color: #64748b; line-height: 1.4; margin-bottom: 10px; }
        .info-pill { 
            font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(0,0,0,0.3);
            border: 1px solid #334155;
        }
    </style>
</head>
<body>

    <div class="viewport">
        <div class="header">
            <span style="font-weight:bold; color:var(--accent)">ECA // 2D HYBRID v2.3</span>
            <div style="display:flex; gap:10px;">
                <label style="font-size:11px; color:#aaa">
                    <input type="checkbox" id="wrap2dCheck" checked onchange="world.setWrap(this.checked)"> Wrap World
                </label>
                <button onclick="world.randomize()">Randomize World</button>
                <button onclick="world.clear()">Clear World</button>
            </div>
        </div>
        <div class="world-wrapper" id="worldWrapper">
            <canvas id="worldCanvas" width="300" height="200"></canvas>
            
            <div id="nbPreview" class="neighborhood-preview">
                <div style="color:#aaa; font-size:10px; margin-bottom:4px">INDEX: <span id="inspIndex" style="color:var(--text)">0</span></div>
                <div class="nb-grid" id="nbGrid"></div>
                <div style="color:#aaa; font-size:10px;">OUTCOME: <span id="inspOutcome" style="font-weight:bold">?</span></div>
            </div>
        </div>
    </div>

    <div class="controls">
        
        <div class="control-block">
            <div class="row">
                <h2>Simulation</h2>
                <div style="display:flex; gap:10px; align-items: center;">
                    <span id="fpsDisplay" style="font-size:11px; color:#888">30 FPS</span>
                    <button id="pauseBtn" class="primary" onclick="togglePause()">STOP</button>
                </div>
            </div>
            <input type="range" id="speedRange" min="1" max="60" value="30">
        </div>

        <div class="control-block">
            <div class="row">
                <h2>1D Gene Strip</h2>
                <div style="display:flex; align-items:center; gap:10px;">
                    <span id="genCount" style="font-size:11px; font-family:monospace">G:0</span>
                    <button id="pauseStripBtn" style="border-color:var(--warn); color:var(--warn); background:transparent" onclick="toggleStripPause()">Pause Gene</button>
                </div>
            </div>
            
            <div class="sub-text">
                <strong style="color:var(--text)">MOUSE CONTROLS (Top Row):</strong><br>
                • <strong>Click:</strong> Toggle State<br>
                • <strong>Shift+Click:</strong> Lock <span style="color:var(--lock-on)">ON</span> (Green)<br>
                • <strong>Ctrl/Alt+Click:</strong> Lock <span style="color:var(--lock-off)">OFF</span> (Red)<br>
                • <strong>Right Click:</strong> Unlock
            </div>
            
            <div class="row" style="margin-top:10px; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px;">
                <div style="display:flex; flex-direction:column; gap:5px; width:100%">
                    <div class="row" style="margin:0">
                        <label style="font-size:11px; color:#aaa">
                            <input type="checkbox" id="wrap1dCheck" checked onchange="strip.setWrap(this.checked)"> Wrap Gene
                        </label>
                        <div style="display:flex; align-items:center; gap:5px;">
                            <span style="font-size:10px; color:#888;">DELAY:</span>
                            <input type="number" id="geneDelayInput" value="1" min="1" max="100" style="width:40px">
                        </div>
                    </div>
                    <div class="row" style="margin:0">
                         <label style="font-size:11px; color:#aaa">Rnd Density:</label>
                         <input type="range" id="stripDensity" min="0" max="100" value="5" style="width:60px">
                    </div>
                </div>
            </div>

            <div class="row" style="justify-content: flex-end; gap: 5px; flex-wrap:wrap">
                <button onclick="strip.stabilize()" class="lock-btn" title="Lock Empty(0) and Full(511) to OFF to prevent flashing">Stabilize (Anti-Flash)</button>
                <button onclick="randomizeStrip()">RND</button>
                <button onclick="strip.seedCenter()">CTR</button>
                <button onclick="strip.seedClear()">CLR</button>
                <button onclick="strip.unlockAll()" style="font-size:10px">Unlock All</button>
            </div>

            <div class="wolfram-display-container" oncontextmenu="return false;">
                <canvas id="wolframCanvas" width="512" height="60"></canvas>
            </div>
        </div>

        <div class="control-block" style="flex:1">
            <div class="row">
                <h2>Elementary Rule</h2>
                <div style="display:flex; gap:5px">
                    <button onclick="randomizeRule()">RND</button>
                    <input type="number" id="ruleInput" value="30" min="0" max="255" onchange="setRuleFromInput(this.value)">
                </div>
            </div>

            <div class="rule-grid" id="ruleGrid"></div>

            <div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top:15px;">
                <h3 style="font-size: 0.8rem; color: #64748b; margin-bottom:10px">Presets</h3>
                <div style="display:flex; gap: 5px; flex-wrap: wrap;">
                    <button onclick="setRule(30)">R30 (Chaos)</button>
                    <button onclick="setRule(90)">R90 (Fractal)</button>
                    <button onclick="setRule(110)">R110 (Comp)</button>
                    <button onclick="setRule(184)">R184 (Flow)</button>
                    <button onclick="setRule(73)">R73 (Wall)</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        /* --- CONFIG --- */
        const W = 300;
        const H = 200;
        const STRIP_LEN = 512; 
        
        /* --- STATE --- */
        let isPaused = false;
        let isStripPaused = false;
        let fps = 30;
        let ruleByte = 30;
        let geneUpdateCounter = 0;
        
        /* --- 1D AUTOMATON --- */
        class Strip {
            constructor() {
                this.cells = new Uint8Array(STRIP_LEN);
                this.next = new Uint8Array(STRIP_LEN);
                // 0: Unlocked, 1: Forced ON, 2: Forced OFF
                this.locks = new Uint8Array(STRIP_LEN); 
                this.history = [];
                this.gen = 0;
                this.wrap = true;
                this.seedCenter();
            }

            setWrap(val) { this.wrap = val; }

            seedCenter() {
                this.cells.fill(0);
                // Preserve locks during reset? Let's say yes for now, 
                // but ensure locked values are applied immediately
                this.applyLocks();
                if(this.locks[Math.floor(STRIP_LEN / 2)] === 0) {
                     this.cells[Math.floor(STRIP_LEN / 2)] = 1; 
                }
                this.resetHistory();
            }

            seedRandom(densityPercent) {
                this.cells.fill(0);
                for(let i=0; i<STRIP_LEN; i++) {
                    if(this.locks[i] !== 0) continue; // Skip locked
                    if(Math.random() * 100 < densityPercent) this.cells[i] = 1;
                }
                this.applyLocks();
                this.resetHistory();
            }

            seedClear() {
                this.cells.fill(0);
                this.applyLocks();
                this.resetHistory();
            }

            // New feature: Lock edges to 0 to prevent flashing
            stabilize() {
                this.locks[0] = 2; // Lock Index 0 (empty neighborhood) to OFF
                this.locks[STRIP_LEN-1] = 2; // Lock Index 511 (full neighborhood) to OFF
                this.applyLocks();
            }

            unlockAll() {
                this.locks.fill(0);
            }

            applyLocks() {
                for(let i=0; i<STRIP_LEN; i++) {
                    if(this.locks[i] === 1) this.cells[i] = 1;
                    if(this.locks[i] === 2) this.cells[i] = 0;
                }
            }

            resetHistory() {
                this.history = new Array(60).fill(null).map(() => new Uint8Array(STRIP_LEN));
                this.history[0].set(this.cells);
                this.gen = 0;
            }

            evolve() {
                for (let i = 0; i < STRIP_LEN; i++) {
                    // Check Locks First
                    if (this.locks[i] === 1) {
                        this.next[i] = 1;
                        continue;
                    }
                    if (this.locks[i] === 2) {
                        this.next[i] = 0;
                        continue;
                    }

                    let leftVal = 0, rightVal = 0;

                    if (this.wrap) {
                        leftVal = this.cells[(i - 1 + STRIP_LEN) % STRIP_LEN];
                        rightVal = this.cells[(i + 1) % STRIP_LEN];
                    } else {
                        const li = i - 1;
                        const ri = i + 1;
                        leftVal = (li < 0) ? 0 : this.cells[li];
                        rightVal = (ri >= STRIP_LEN) ? 0 : this.cells[ri];
                    }

                    const center = this.cells[i];
                    const pattern = (leftVal << 2) | (center << 1) | rightVal;
                    this.next[i] = (ruleByte >> pattern) & 1;
                }
                [this.cells, this.next] = [this.next, this.cells];
                
                this.history.pop();
                this.history.unshift(new Uint8Array(this.cells));
                this.gen++;
            }
        }

        /* --- 2D WORLD --- */
        class World {
            constructor(w, h) {
                this.w = w; this.h = h;
                this.data = new Uint8Array(w * h);
                this.next = new Uint8Array(w * h);
                this.wrap = true;
                this.randomize();
            }

            setWrap(val) { this.wrap = val; }

            randomize() {
                for(let i=0; i<this.data.length; i++) this.data[i] = Math.random() > 0.85 ? 1 : 0;
            }
            
            clear() { this.data.fill(0); }

            getNeighborhood(x, y) {
                let index = 0;
                let bitPos = 8;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        let ny, nx, val = 0;
                        if (this.wrap) {
                            ny = (y + dy + this.h) % this.h;
                            nx = (x + dx + this.w) % this.w;
                            val = this.data[ny * this.w + nx];
                        } else {
                            ny = y + dy;
                            nx = x + dx;
                            if (ny >= 0 && ny < this.h && nx >= 0 && nx < this.w) {
                                 val = this.data[ny * this.w + nx];
                            }
                        }
                        if (val === 1) index |= (1 << bitPos);
                        bitPos--;
                    }
                }
                return index;
            }

            update(controllerStrip) {
                const d = this.data;
                const n = this.next;
                const w = this.w;
                const h = this.h;
                const strip = controllerStrip.cells;

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let index = 0;
                        let bitPos = 8;
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                let ny, nx, val = 0;
                                if (this.wrap) {
                                    ny = (y + dy + h) % h;
                                    nx = (x + dx + w) % w;
                                    val = d[ny * w + nx];
                                } else {
                                    ny = y + dy;
                                    nx = x + dx;
                                    if(ny >= 0 && ny < h && nx >= 0 && nx < w) {
                                         val = d[ny * w + nx];
                                    }
                                }
                                if (val === 1) index |= (1 << bitPos);
                                bitPos--;
                            }
                        }
                        n[y * w + x] = strip[index];
                    }
                }
                [this.data, this.next] = [this.next, this.data];
            }
        }

        /* --- INIT --- */
        const strip = new Strip();
        const world = new World(W, H);

        /* --- RENDERERS --- */
        const worldCtx = document.getElementById('worldCanvas').getContext('2d');
        const wolframCtx = document.getElementById('wolframCanvas').getContext('2d');
        const worldImgData = worldCtx.createImageData(W, H);
        const wolframImgData = wolframCtx.createImageData(512, 60);

        function drawWorld() {
            const buf = new Uint32Array(worldImgData.data.buffer);
            const len = world.data.length;
            // Palette: 
            // Dead: 0xFF1e1b20 (Dark Slate/Blackish) -> ABGR 0xFF201B1E ? No, let's use HEX logic
            // JS uses Little Endian usually. AABBGGRR.
            // Dead: #020617 -> 0xFF170602
            // Alive: #38bdf8 (Sky Blue 400) -> 0xFFF8BD38
            
            const colDead = 0xFF170602; 
            const colAlive = 0xFFF8BD38;

            for(let i=0; i<len; i++) {
                buf[i] = world.data[i] ? colAlive : colDead; 
            }
            worldCtx.putImageData(worldImgData, 0, 0);
        }

        function drawWolfram() {
            const buf = new Uint32Array(wolframImgData.data.buffer);
            for(let y=0; y<60; y++) {
                const row = strip.history[y];
                if(!row) continue;
                
                const isActiveRow = (y === 0);

                for(let x=0; x<512; x++) {
                    const val = row[x];
                    let col = 0xFF000000;
                    
                    if(isActiveRow) {
                        // Check locks for coloring
                        const lock = strip.locks[x];
                        
                        if (val) col = 0xFFFFFFFF; // White for ON
                        else col = 0xFF222222;    // Dark Grey for OFF
                        
                        // Overlay Lock Colors (Subtle tint or bar)
                        // Note: putImageData doesn't support transparency blending well manually without cost
                        // We will draw locks as a separate pass using fillRect for clarity
                    } else {
                        // Fading History - Softer colors (Cyan/Teal fade)
                        // #0ea5e9 to dark
                        const fade = Math.max(10, 180 - (y*3));
                        if(val) {
                            // ABGR
                            col = (255 << 24) | (200 << 16) | (165 << 8) | 14; 
                        } else {
                            col = 0xFF050505;
                        }
                    }
                    buf[y*512 + x] = col;
                }
            }
            wolframCtx.putImageData(wolframImgData, 0, 0);

            // Draw Lock Indicators on top row
            for(let x=0; x<512; x++) {
                const lock = strip.locks[x];
                if(lock === 1) { // Forced ON
                    wolframCtx.fillStyle = '#4ade80';
                    wolframCtx.fillRect(x, 0, 1, 2); // Top bar
                    wolframCtx.fillRect(x, 0, 1, 1); // Ensure white pixel is covered slightly or tinted
                } else if(lock === 2) { // Forced OFF
                    wolframCtx.fillStyle = '#ef4444';
                    wolframCtx.fillRect(x, 0, 1, 2);
                }
            }
        }

        /* --- UI & INTERACTION --- */
        
        function buildRuleUI() {
            const grid = document.getElementById('ruleGrid');
            grid.innerHTML = '';
            document.getElementById('ruleInput').value = ruleByte;
            
            for(let i=7; i>=0; i--) {
                const isActive = (ruleByte >> i) & 1;
                const div = document.createElement('div');
                div.className = `rule-bit ${isActive ? 'active' : ''}`;
                div.onclick = () => toggleBit(i);
                
                let patHTML = '<div class="bit-pattern">';
                patHTML += `<div class="bit-cell ${(i>>2)&1 ? 'on':''}"></div>`;
                patHTML += `<div class="bit-cell ${(i>>1)&1 ? 'on':''}"></div>`;
                patHTML += `<div class="bit-cell ${(i)&1 ? 'on':''}"></div>`;
                patHTML += '</div>';

                div.innerHTML = `${patHTML}<div class="bit-val">${isActive}</div>`;
                grid.appendChild(div);
            }
        }

        function toggleBit(bit) {
            ruleByte ^= (1 << bit);
            buildRuleUI();
        }

        function setRule(n) {
            ruleByte = n;
            buildRuleUI();
        }

        function randomizeRule() {
            setRule(Math.floor(Math.random() * 256));
        }

        function setRuleFromInput(val) {
            let n = parseInt(val);
            if(isNaN(n)) n = 0;
            n = Math.max(0, Math.min(255, n));
            setRule(n);
        }

        /* --- STRIP CONTROLS --- */
        function randomizeStrip() {
            const density = parseInt(document.getElementById('stripDensity').value);
            strip.seedRandom(density);
        }

        /* --- SIM CONTROLS --- */
        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            btn.innerText = isPaused ? "START" : "STOP";
            btn.className = isPaused ? "run" : "primary";
            btn.style.backgroundColor = isPaused ? "var(--run)" : "var(--stop)";
            btn.style.borderColor = isPaused ? "var(--run)" : "var(--stop)";
        }

        function toggleStripPause() {
            isStripPaused = !isStripPaused;
            const btn = document.getElementById('pauseStripBtn');
            btn.innerText = isStripPaused ? "Resume Gene" : "Pause Gene";
            if(isStripPaused) {
                btn.style.color = "var(--text)";
                btn.style.borderColor = "var(--text)";
            }
            else {
                btn.style.color = "var(--warn)";
                btn.style.borderColor = "var(--warn)";
            }
        }

        document.getElementById('speedRange').addEventListener('input', (e) => {
            fps = parseInt(e.target.value);
            document.getElementById('fpsDisplay').innerText = fps + " FPS";
        });

        /* --- MOUSE DRAWING & INSPECTION --- */
        let isDrawing = false;
        let isDrawingStrip = false;
        
        const worldCvs = document.getElementById('worldCanvas');
        const wolfCvs = document.getElementById('wolframCanvas');
        const nbPreview = document.getElementById('nbPreview');
        const nbGrid = document.getElementById('nbGrid');
        const inspIndex = document.getElementById('inspIndex');
        const inspOutcome = document.getElementById('inspOutcome');

        // Helper for mouse pos
        const getPos = (e, canvas) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: Math.floor((e.clientX - rect.left) * scaleX),
                y: Math.floor((e.clientY - rect.top) * scaleY)
            };
        }

        // --- World Interactions ---
        const paintWorld = (e) => {
            const {x, y} = getPos(e, worldCvs);
            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    if (x+dx>=0 && x+dx<W && y+dy>=0 && y+dy<H) {
                        world.data[(y+dy)*W + (x+dx)] = 1;
                    }
                }
            }
            drawWorld();
        };

        const inspectWorld = (e) => {
            const {x, y} = getPos(e, worldCvs);
            if(x < 0 || x >= W || y < 0 || y >= H) {
                nbPreview.style.display = 'none';
                return;
            }

            const index = world.getNeighborhood(x, y);
            const outcome = strip.cells[index];

            nbPreview.style.display = 'block';
            inspIndex.innerText = index;
            inspOutcome.innerText = outcome ? "LIVES" : "DIES";
            inspOutcome.style.color = outcome ? "var(--run)" : "var(--stop)";

            nbGrid.innerHTML = '';
            for(let i=8; i>=0; i--) {
                const isOn = (index >> i) & 1;
                const d = document.createElement('div');
                d.className = `nb-cell ${isOn ? 'on' : ''} ${i===4 ? 'center':''}`;
                nbGrid.appendChild(d);
            }
        }

        worldCvs.addEventListener('mousedown', (e) => { isDrawing = true; paintWorld(e); });
        worldCvs.addEventListener('mousemove', (e) => { 
            if(isDrawing) paintWorld(e); 
            else inspectWorld(e);
        });
        worldCvs.addEventListener('mouseleave', () => nbPreview.style.display = 'none');
        
        // --- Strip Interactions (Painting & Locking) ---
        const interactStrip = (e) => {
            const {x, y} = getPos(e, wolfCvs);
            if(x >= 0 && x < STRIP_LEN) {
                // Determine Action based on keys/buttons
                if (e.buttons === 2) { // Right Click
                    strip.locks[x] = 0; // Unlock
                    // Just visual update, actual value determined by sim next frame
                } else if (e.shiftKey) { // Shift + Left
                    strip.locks[x] = 1; // Force ON
                    strip.cells[x] = 1; 
                } else if (e.ctrlKey || e.altKey) { // Ctrl/Alt + Left
                    strip.locks[x] = 2; // Force OFF
                    strip.cells[x] = 0;
                } else if (e.buttons === 1) { // Normal Left
                     // Only toggle/paint if not locked? 
                     // Let's allow painting to override visual, but lock holds next frame
                     // For pure painting, we just set cell to 1
                     if(strip.locks[x] === 0) strip.cells[x] = 1;
                }

                strip.history[0][x] = strip.cells[x];
                drawWolfram();
            }
        }

        wolfCvs.addEventListener('mousedown', (e) => { 
            isDrawingStrip = true; 
            interactStrip(e); 
        });
        wolfCvs.addEventListener('mousemove', (e) => { 
            if(isDrawingStrip) interactStrip(e); 
        });
        
        window.addEventListener('mouseup', () => {
            isDrawing = false;
            isDrawingStrip = false;
        });

        /* --- LOOP --- */
        let lastTime = 0;
        
        function loop(time) {
            if (!isPaused && time - lastTime > 1000 / fps) {
                
                // 1. Update World (Every frame)
                world.update(strip);
                
                // 2. Logic to delay Strip update based on input
                geneUpdateCounter++;
                const delay = parseInt(document.getElementById('geneDelayInput').value) || 1;

                if(geneUpdateCounter >= delay) {
                    if(!isStripPaused) {
                        strip.evolve();
                        document.getElementById('genCount').innerText = "G:" + strip.gen;
                    } else {
                        // Even if paused, we ensure locks are applied
                        strip.applyLocks();
                    }
                    geneUpdateCounter = 0;
                }
                
                lastTime = time;
            }
            
            drawWorld();
            drawWolfram();
            requestAnimationFrame(loop);
        }

        buildRuleUI();
        requestAnimationFrame(loop);

    </script>
</body>
</html>