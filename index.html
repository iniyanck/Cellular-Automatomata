<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CELLULAR AUTOMATOMATA V2</title>
    <style>
        /* --- THEMES --- */
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #94a3b8;
            --text-head: #e2e8f0;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);
            --border: #334155;
            --run: #10b981;
            --stop: #f43f5e;
            --warn: #f97316;
            --lock-on: #4ade80;
            --lock-off: #ef4444;
            
            --cell-dead: #020617;
            --cell-alive: #38bdf8;
            
            --font-main: 'Segoe UI', 'Roboto', monospace;
        }

        /* Matrix Theme */
        [data-theme="matrix"] {
            --bg: #000000; --panel: #0a0a0a; --text: #008f11; --text-head: #00ff41;
            --accent: #00ff41; --accent-glow: rgba(0, 255, 65, 0.4);
            --border: #003b00; --run: #00ff41; --stop: #005c00; --warn: #ccff00;
            --lock-on: #afffaf; --lock-off: #003300;
            --cell-dead: #000500; --cell-alive: #00ff41;
        }

        /* Magma Theme */
        [data-theme="magma"] {
            --bg: #1a0505; --panel: #2a0a0a; --text: #dcbaba; --text-head: #ffcccc;
            --accent: #ff4500; --accent-glow: rgba(255, 69, 0, 0.4);
            --border: #551111; --run: #ff8800; --stop: #880000; --warn: #ffcc00;
            --lock-on: #ffaa55; --lock-off: #550000;
            --cell-dead: #110000; --cell-alive: #ff4500;
        }

        /* Paper Theme */
        [data-theme="paper"] {
            --bg: #f8fafc; --panel: #ffffff; --text: #475569; --text-head: #0f172a;
            --accent: #3b82f6; --accent-glow: rgba(59, 130, 246, 0.2);
            --border: #e2e8f0; --run: #22c55e; --stop: #ef4444; --warn: #f59e0b;
            --lock-on: #15803d; --lock-off: #b91c1c;
            --cell-dead: #ffffff; --cell-alive: #0f172a;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-size: 13px;
        }

        /* --- LAYOUT --- */
        .viewport {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .controls {
            width: 420px;
            min-width: 420px;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            border-left: 1px solid var(--border);
            z-index: 20;
        }

        /* --- HEADER --- */
        .header {
            padding: 8px 12px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; gap: 8px;
            z-index: 10;
        }

        /* --- CANVAS AREAS --- */
        .world-wrapper {
            flex: 1;
            background: var(--cell-dead); /* Matches canvas bg for seamless look */
            position: relative; 
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        canvas#worldCanvas {
            image-rendering: pixelated;
            position: absolute;
            left: 0; top: 0;
            cursor: crosshair;
            width: 100%; height: 100%;
        }

        /* --- GENE / WOLFRAM AREA --- */
        .wolfram-container {
            display: flex; gap: 0; 
            margin-top: 10px;
            height: 80px; /* Locked height via CSS */
            background: var(--bg);
            border: 1px solid var(--border);
        }

        .wolfram-canvas-box {
            position: relative;
            flex: 1;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
        }

        canvas#wolframCanvas {
            width: 100%; height: 100%;
            image-rendering: pixelated;
            display: block; cursor: crosshair;
        }

        /* Vertical slider for history */
        .history-slider-box {
            width: 20px; 
            height: 100%;
            display: flex; 
            flex-direction: column; 
            align-items: center;
            background: var(--panel);
            border-left: 1px solid var(--border);
            position: relative;
        }
        
        input[type=range][orient=vertical] {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 100%; height: 100%; padding: 0; margin: 0;
            cursor: ns-resize;
        }

        .history-tooltip {
            position: absolute;
            right: 25px;
            background: var(--accent);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            pointer-events: none;
            white-space: nowrap;
            display: none;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            z-index: 100;
        }

        /* --- INSPECTOR OVERLAY (FIXED) --- */
        .neighborhood-preview {
            position: absolute; 
            bottom: 10px; left: 10px;
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid var(--border);
            backdrop-filter: blur(4px);
            padding: 8px; border-radius: 4px; pointer-events: none;
            display: none; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            z-index: 50;
            width: 90px; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .nb-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; margin-bottom: 5px; }
        .nb-cell { width: 10px; height: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); }
        .nb-cell.on { background: var(--accent); box-shadow: 0 0 4px var(--accent); border-color: var(--accent); }
        .nb-cell.center { border: 1px solid var(--text-head); }

        /* --- CONTROLS CSS --- */
        .control-block { padding: 15px; border-bottom: 1px solid var(--border); background: var(--panel); }
        h2 { margin: 0 0 12px 0; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-head); }
        button {
            background: var(--panel); border: 1px solid var(--border); color: var(--text-head);
            padding: 4px 10px; cursor: pointer; border-radius: 4px;
            font-family: inherit; transition: all 0.2s; font-size: 11px; text-transform: uppercase;
        }
        button:hover { background: var(--border); transform: translateY(-1px); }
        button.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
        button.primary:hover { box-shadow: 0 0 10px var(--accent-glow); background: var(--accent); }
        button.lock-btn { border-color: var(--lock-on); color: var(--lock-on); background: transparent; }
        button.lock-btn:hover { background: rgba(74, 222, 128, 0.1); }
        button.icon-btn { padding: 4px 8px; font-size: 10px; }
        button.del-btn { border-color: var(--stop); color: var(--stop); background: transparent; }
        
        input[type="range"] { width: 100%; cursor: pointer; }
        input[type="number"], input[type="text"], select {
            background: var(--bg); border: 1px solid var(--border); color: var(--text-head);
            padding: 4px; border-radius: 4px; font-family: monospace; font-size: 11px;
        }
        
        .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .sub-text { font-size: 10px; color: var(--text); line-height: 1.4; margin-bottom: 10px; opacity: 0.8; }
        
        /* Rule Bits */
        .rule-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; margin-top: 15px; }
        .rule-bit {
            display: flex; flex-direction: column; align-items: center;
            cursor: pointer; padding: 6px 2px;
            background: rgba(255,255,255,0.03); border: 1px solid transparent; border-radius: 4px;
        }
        .rule-bit.active { border-color: var(--accent); background: var(--accent-glow); }
        .bit-pattern { display: flex; gap: 1px; margin-bottom: 6px; }
        .bit-cell { width: 4px; height: 4px; background: var(--border); }
        .bit-cell.on { background: var(--text); }
        .bit-val { font-size: 10px; color: var(--text); font-weight: bold; }
        .rule-bit.active .bit-val { color: var(--accent); }

        /* Presets */
        .preset-list {
            display: flex; flex-direction: column; gap: 4px; margin-top: 10px;
            max-height: 100px; overflow-y: auto;
            border: 1px solid var(--border); padding: 4px; border-radius: 4px;
            background: rgba(0,0,0,0.1);
        }
        .preset-item {
            display: flex; justify-content: space-between; align-items: center;
            background: var(--panel); padding: 4px 8px; border-radius: 3px;
            border: 1px solid transparent; cursor: pointer;
        }
        .preset-item:hover { border-color: var(--accent); }
    </style>
</head>
<body>

    <input type="file" id="importFile" accept=".json" style="display:none" onchange="handleFileImport(this)">

    <div class="viewport">
        <div class="header">
            <span style="font-weight:bold; color:var(--accent); font-size:1.1em; letter-spacing:1px;">CELLULAR AUTOMATOMATA V2</span>
            <div style="display:flex; gap:10px; align-items: center;">
                <select id="themeSelect" onchange="setTheme(this.value)">
                    <option value="cyber">Theme: Cyber</option>
                    <option value="matrix">Theme: Matrix</option>
                    <option value="magma">Theme: Magma</option>
                    <option value="paper">Theme: Paper</option>
                </select>
                <div style="width:1px; height:20px; background:var(--border)"></div>
                
                <div style="display:flex; align-items:center; gap:5px" title="Paintbrush Size">
                    <span>Brush:</span>
                    <input type="number" id="brushSize" value="1" min="1" max="10" style="width:35px">
                </div>

                <div style="width:1px; height:20px; background:var(--border)"></div>

                <label style="font-size:11px;">
                    <input type="checkbox" id="wrap2dCheck" checked onchange="world.setWrap(this.checked)"> Wrap
                </label>
                <button onclick="world.randomize()">RND</button>
                <button onclick="world.clear()">CLR</button>
                <button class="primary" onclick="resetWorldCam()">Fit View</button>
            </div>
        </div>
        
        <div class="world-wrapper" id="worldWrapper" oncontextmenu="return false;">
            <canvas id="worldCanvas" width="600" height="400"></canvas>
            
            <div id="nbPreview" class="neighborhood-preview">
                <div style="font-size:10px; margin-bottom:4px; color:var(--text)">IDX: <span id="inspIndex" style="color:var(--text-head)">0</span></div>
                <div class="nb-grid" id="nbGrid"></div>
                <div style="font-size:10px; color:var(--text)">OUT: <span id="inspOutcome" style="font-weight:bold">?</span></div>
            </div>
        </div>
    </div>

    <div class="controls">
        
        <div class="control-block">
            <div class="row">
                <h2>Simulation</h2>
                <div style="display:flex; gap:10px; align-items: center;">
                    <span id="fpsDisplay" style="font-size:11px; opacity:0.7">30 FPS</span>
                    <button id="pauseBtn" class="primary" onclick="togglePause()">STOP</button>
                </div>
            </div>
            <input type="range" id="speedRange" min="1" max="60" value="30">
        </div>

        <div class="control-block">
            <div class="row">
                <h2>Gene Strip (Mask)</h2>
                <div style="display:flex; align-items:center; gap:10px;">
                    <span id="genCount" style="font-size:11px; font-family:monospace">G:0</span>
                    <button id="pauseStripBtn" style="border-color:var(--warn); color:var(--warn); background:transparent" onclick="toggleStripPause()">Pause Gene</button>
                </div>
            </div>
            
            <div class="sub-text">
                <strong>ZOOM:</strong> Scroll (at cursor) | <strong>PAN:</strong> Middle/Left Drag<br>
                <strong>2D:</strong> Right Click Erase | <strong>GENE:</strong> Click toggles
            </div>
            
            <div class="row" style="margin-top:10px; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px;">
                <div style="display:flex; flex-direction:column; gap:5px; width:100%">
                    <div class="row" style="margin:0">
                        <label style="font-size:11px;" title="Edges connect">
                            <input type="checkbox" id="wrap1dCheck" checked onchange="strip.setWrap(this.checked)"> Wrap
                        </label>
                        <div style="display:flex; align-items:center; gap:5px;">
                            <span style="font-size:10px;">DELAY:</span>
                            <input type="number" id="geneDelayInput" value="1" min="1" max="100" style="width:40px">
                        </div>
                    </div>
                    <div class="row" style="margin:0">
                         <span style="font-size:11px;">Rnd Density:</span>
                         <input type="number" id="stripDensity" min="0" max="100" value="5" style="width:50px">
                    </div>
                    <div class="row" style="margin:0; border-top:1px solid rgba(255,255,255,0.1); padding-top:4px; margin-top:2px;">
                        <label style="font-size:11px; color:var(--accent);" title="Pattern ignores locks, locks only apply to output">
                            <input type="checkbox" id="ghostMaskCheck" onchange="strip.setGhost(this.checked)"> Ghost Mask
                        </label>
                    </div>
                </div>
            </div>

            <div class="row" style="justify-content: flex-end; gap: 5px; flex-wrap:wrap">
                <button onclick="strip.stabilize()" class="lock-btn">Stabilize</button>
                <button onclick="randomizeStrip()">RND</button>
                <button onclick="strip.seedCenter()">CTR</button>
                <button onclick="strip.seedClear()">CLR</button>
                <button onclick="strip.unlockAll()" style="font-size:10px">Unlk</button>
            </div>

            <div class="wolfram-container" oncontextmenu="return false;">
                <div class="wolfram-canvas-box" id="wolfWrapper">
                    <canvas id="wolframCanvas" width="512" height="80"></canvas>
                </div>
                <div class="history-slider-box">
                    <input type="range" orient="vertical" id="historySlider" min="0" max="79" value="79" oninput="updateHistoryUI()">
                    <div id="historyTooltip" class="history-tooltip">0</div>
                </div>
            </div>
            
            <div class="row" style="margin-top:5px; justify-content: flex-end;">
                 <button onclick="restoreHistory()" style="font-size:10px; width:100%">Restore Selected Row</button>
            </div>

            <div style="margin-top: 15px; border-top: 1px solid var(--border); padding-top:10px;">
                <div class="row">
                    <h3 style="margin:0; font-size:11px; color:var(--text)">Mask IO</h3>
                    <div style="display:flex; gap:5px">
                        <button class="icon-btn" onclick="triggerImport()" title="Load JSON">Import</button>
                        <button class="icon-btn" onclick="triggerExport()" title="Save JSON">Export</button>
                    </div>
                </div>
                <div class="row" style="margin-top:8px">
                    <h3 style="margin:0; font-size:11px; color:var(--text)">Mask Presets</h3>
                    <div style="display:flex; gap:5px">
                        <input type="text" id="maskNameInput" placeholder="Name" style="width:70px">
                        <button class="icon-btn primary" onclick="saveMaskPreset()">Save</button>
                    </div>
                </div>
                <div id="maskPresetList" class="preset-list"></div>
            </div>
        </div>

        <div class="control-block" style="flex:1">
            <div class="row">
                <h2>Elementary Rule</h2>
                <div style="display:flex; gap:5px">
                    <button onclick="randomizeRule()">RND</button>
                    <input type="number" id="ruleInput" value="30" min="0" max="255" onchange="setRuleFromInput(this.value)">
                </div>
            </div>

            <div class="rule-grid" id="ruleGrid"></div>

            <div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top:15px;">
                <div class="row">
                    <h3 style="margin:0; font-size:11px; color:var(--text)">Rule Presets</h3>
                    <div style="display:flex; gap:5px">
                        <input type="text" id="ruleNameInput" placeholder="Name" style="width:70px">
                        <button class="icon-btn primary" onclick="saveRulePreset()">Save</button>
                    </div>
                </div>
                <div id="rulePresetList" class="preset-list"></div>
            </div>
        </div>
    </div>

    <script>
        /* --- CONFIG --- */
        const W = 600; 
        const H = 400;
        const STRIP_LEN = 512; 
        const HISTORY_LEN = 80; 
        
        /* --- STATE --- */
        let isPaused = false;
        let isStripPaused = false;
        let fps = 30;
        let ruleByte = 30;
        let geneUpdateCounter = 0;
        let selectedHistoryIndex = 0; 
        let geneDrawMode = 1; // 1 = Draw, 0 = Erase
        let lockMode = 0;
        let lastInspIndex = -1;
        
        /* --- HELPERS --- */
        function getCssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
            const bigint = parseInt(hex, 16);
            return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
        }
        function getPalette() {
            const dead = hexToRgb(getCssVar('--cell-dead'));
            const alive = hexToRgb(getCssVar('--cell-alive'));
            const colDead = (255 << 24) | (dead.b << 16) | (dead.g << 8) | dead.r;
            const colAlive = (255 << 24) | (alive.b << 16) | (alive.g << 8) | alive.r;
            return { colDead, colAlive };
        }
        function setTheme(themeName) {
            document.documentElement.setAttribute('data-theme', themeName);
            drawWorld(); drawWolfram();
        }

        /* --- CAMERA CLASS --- */
        class Camera {
            constructor(canvas, contentW, contentH) {
                this.canvas = canvas;
                this.cW = contentW; this.cH = contentH;
                this.zoom = 1;
                this.offsetX = 0; this.offsetY = 0;
                this.isDragging = false;
                this.lastX = 0; this.lastY = 0;
                this.minZoom = 0.1;
                this.maxZoom = 40;
            }

            resetToFit(mode = 'contain') {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const scaleX = rect.width / this.cW;
                const scaleY = rect.height / this.cH;
                let fitScale;
                
                if(mode === 'cover') {
                    fitScale = Math.max(scaleX, scaleY) * 1.001; 
                } else {
                    fitScale = Math.min(scaleX, scaleY);
                }
                this.zoom = fitScale;
                this.minZoom = fitScale; 
                this.constrain(); 
            }

            screenToWorld(sx, sy) {
                const rect = this.canvas.getBoundingClientRect();
                const cssX = sx - rect.left;
                const cssY = sy - rect.top;
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const internalX = cssX * scaleX;
                const internalY = cssY * scaleY;
                return {
                    x: (internalX - this.offsetX) / this.zoom,
                    y: (internalY - this.offsetY) / this.zoom
                };
            }

            apply(ctx) {
                ctx.save();
                ctx.translate(this.offsetX, this.offsetY);
                ctx.scale(this.zoom, this.zoom);
            }
            
            constrain() {
                const viewW = this.canvas.width;
                const viewH = this.canvas.height;
                const contentW = this.cW * this.zoom;
                const contentH = this.cH * this.zoom;
                
                if (contentW > viewW + 0.1) {
                    if (this.offsetX > 0) this.offsetX = 0;
                    if (this.offsetX < viewW - contentW) this.offsetX = viewW - contentW;
                } else {
                    this.offsetX = (viewW - contentW) / 2;
                }

                if (contentH > viewH + 0.1) {
                    if (this.offsetY > 0) this.offsetY = 0;
                    if (this.offsetY < viewH - contentH) this.offsetY = viewH - contentH;
                } else {
                    this.offsetY = (viewH - contentH) / 2;
                }
            }
        }

        /* --- 1D AUTOMATON --- */
        class Strip {
            constructor() {
                this.cells = new Uint8Array(STRIP_LEN);
                this.next = new Uint8Array(STRIP_LEN);
                this.locks = new Uint8Array(STRIP_LEN); 
                this.history = [];
                this.gen = 0;
                this.wrap = true;
                this.ghostMode = false;
                this.seedCenter();
            }
            setWrap(val) { this.wrap = val; }
            setGhost(val) { this.ghostMode = val; }

            seedCenter() {
                this.cells.fill(0); this.applyLocks();
                // Only seed if center not locked to 0
                if(this.locks[Math.floor(STRIP_LEN / 2)] !== 2) this.cells[Math.floor(STRIP_LEN / 2)] = 1; 
                this.resetHistory();
            }
            seedRandom(densityPercent) {
                this.cells.fill(0);
                for(let i=0; i<STRIP_LEN; i++) {
                    // If hard locked, skip randomization to respect lock
                    if(!this.ghostMode && this.locks[i] !== 0) continue; 
                    if(Math.random() * 100 < densityPercent) this.cells[i] = 1;
                }
                this.applyLocks(); this.resetHistory();
            }
            seedClear() { this.cells.fill(0); this.applyLocks(); this.resetHistory(); }
            
            // Mask Import/Export
            loadData(data) {
                if(data.cells && data.cells.length === STRIP_LEN) {
                    for(let i=0; i<STRIP_LEN; i++) this.cells[i] = data.cells[i];
                }
                if(data.locks && data.locks.length === STRIP_LEN) {
                    for(let i=0; i<STRIP_LEN; i++) this.locks[i] = data.locks[i];
                }
                this.resetHistory();
                drawWolfram();
            }
            
            loadMask(maskData) {
                for(let i=0; i<STRIP_LEN; i++) this.cells[i] = maskData[i] ? 1 : 0;
                this.applyLocks(); this.resetHistory();
            }
            
            stabilize() { this.locks[0] = 2; this.locks[STRIP_LEN-1] = 2; this.applyLocks(); drawWolfram(); }
            unlockAll() { this.locks.fill(0); drawWolfram(); }
            
            // Helper to get effective value for output/display
            getRenderValue(i) {
                if (this.ghostMode) {
                    // In ghost mode, locks override the simulation for display/output purposes
                    if (this.locks[i] === 1) return 1;
                    if (this.locks[i] === 2) return 0;
                }
                return this.cells[i];
            }

            applyLocks() {
                // In Ghost Mode, we do NOT modify this.cells based on locks, 
                // because we want the simulation to flow "under" them.
                // In Normal Mode, locks overwrite this.cells.
                if(!this.ghostMode) {
                    for(let i=0; i<STRIP_LEN; i++) {
                        if(this.locks[i] === 1) this.cells[i] = 1;
                        if(this.locks[i] === 2) this.cells[i] = 0;
                    }
                }
            }
            
            resetHistory() {
                this.history = new Array(HISTORY_LEN).fill(null).map(() => new Uint8Array(STRIP_LEN));
                this.history[0].set(this.cells); // Store raw cells
                this.gen = 0;
            }
            
            evolve() {
                for (let i = 0; i < STRIP_LEN; i++) {
                    // Hard Lock Logic: if locked and NOT ghost, cell is fixed.
                    if (!this.ghostMode) {
                        if (this.locks[i] === 1) { this.next[i] = 1; continue; }
                        if (this.locks[i] === 2) { this.next[i] = 0; continue; }
                    }

                    let leftVal = 0, rightVal = 0;
                    if (this.wrap) {
                        leftVal = this.cells[(i - 1 + STRIP_LEN) % STRIP_LEN];
                        rightVal = this.cells[(i + 1) % STRIP_LEN];
                    } else {
                        const li = i - 1; const ri = i + 1;
                        leftVal = (li < 0) ? 0 : this.cells[li];
                        rightVal = (ri >= STRIP_LEN) ? 0 : this.cells[ri];
                    }
                    const center = this.cells[i];
                    const pattern = (leftVal << 2) | (center << 1) | rightVal;
                    this.next[i] = (ruleByte >> pattern) & 1;
                }
                
                [this.cells, this.next] = [this.next, this.cells];
                
                this.history.pop();
                // We save the raw simulation state to history
                this.history.unshift(new Uint8Array(this.cells));
                this.gen++;
            }
        }

        /* --- 2D WORLD --- */
        class World {
            constructor(w, h) {
                this.w = w; this.h = h;
                this.data = new Uint8Array(w * h);
                this.next = new Uint8Array(w * h);
                this.wrap = true;
                this.randomize();
            }
            setWrap(val) { this.wrap = val; }
            randomize() { for(let i=0; i<this.data.length; i++) this.data[i] = Math.random() > 0.85 ? 1 : 0; }
            clear() { this.data.fill(0); }
            getNeighborhood(x, y) {
                let index = 0; let bitPos = 8;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        let ny, nx, val = 0;
                        if (this.wrap) {
                            ny = (y + dy + this.h) % this.h; nx = (x + dx + this.w) % this.w;
                            val = this.data[ny * this.w + nx];
                        } else {
                            ny = y + dy; nx = x + dx;
                            if (ny >= 0 && ny < this.h && nx >= 0 && nx < this.w) val = this.data[ny * this.w + nx];
                        }
                        if (val === 1) index |= (1 << bitPos);
                        bitPos--;
                    }
                }
                return index;
            }
            update(controllerStrip) {
                const d = this.data; const n = this.next;
                const w = this.w; const h = this.h;
                
                // Pre-calculate effective rule set from strip
                // This accounts for Ghost Mode overrides
                const ruleSet = new Uint8Array(512);
                for(let i=0; i<512; i++) {
                    ruleSet[i] = controllerStrip.getRenderValue(i);
                }

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let index = 0; let bitPos = 8;
                        // Manual loop unrolling for slight perf boost not strictly needed here but good practice
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                let ny, nx, val = 0;
                                if (this.wrap) {
                                    ny = (y + dy + h) % h; nx = (x + dx + w) % w;
                                    val = d[ny * w + nx];
                                } else {
                                    ny = y + dy; nx = x + dx;
                                    if(ny >= 0 && ny < h && nx >= 0 && nx < w) val = d[ny * w + nx];
                                }
                                if (val === 1) index |= (1 << bitPos);
                                bitPos--;
                            }
                        }
                        n[y * w + x] = ruleSet[index];
                    }
                }
                [this.data, this.next] = [this.next, this.data];
            }
        }

        /* --- INIT --- */
        const strip = new Strip();
        const world = new World(W, H);

        /* --- CANVAS & CAMS --- */
        const worldCvs = document.getElementById('worldCanvas');
        const worldCtx = worldCvs.getContext('2d');
        const worldCam = new Camera(worldCvs, W, H);

        const wolfCvs = document.getElementById('wolframCanvas');
        const wolfCtx = wolfCvs.getContext('2d');
        const wolfCam = new Camera(wolfCvs, 512, 80); 

        // Offscreen buffers
        const worldBuffer = document.createElement('canvas'); worldBuffer.width = W; worldBuffer.height = H;
        const worldBufCtx = worldBuffer.getContext('2d');
        const worldImgData = worldBufCtx.createImageData(W, H);

        const wolfBuffer = document.createElement('canvas'); wolfBuffer.width = 512; wolfBuffer.height = 80;
        const wolfBufCtx = wolfBuffer.getContext('2d');
        const wolfImgData = wolfBufCtx.createImageData(512, 80);

        function resetWorldCam() {
            worldCam.resetToFit('cover');
            wolfCam.resetToFit('contain'); 
            drawWorld(); drawWolfram();
        }

        const resizeObserver = new ResizeObserver(() => {
            const wRect = document.getElementById('worldWrapper').getBoundingClientRect();
            worldCvs.width = wRect.width; worldCvs.height = wRect.height;
            
            const wfRect = document.getElementById('wolfWrapper').getBoundingClientRect();
            wolfCvs.width = wfRect.width; wolfCvs.height = wfRect.height;
            
            worldCam.resetToFit('cover'); 
            wolfCam.resetToFit('contain');
            
            drawWorld(); drawWolfram();
        });
        resizeObserver.observe(document.getElementById('worldWrapper'));
        resizeObserver.observe(document.getElementById('wolfWrapper'));

        /* --- RENDER LOGIC --- */
        function drawWorld() {
            const buf = new Uint32Array(worldImgData.data.buffer);
            const { colDead, colAlive } = getPalette();
            for(let i=0; i<world.data.length; i++) buf[i] = world.data[i] ? colAlive : colDead; 
            worldBufCtx.putImageData(worldImgData, 0, 0);

            worldCtx.fillStyle = getCssVar('--cell-dead');
            worldCtx.fillRect(0,0, worldCvs.width, worldCvs.height);
            worldCam.apply(worldCtx);
            worldCtx.imageSmoothingEnabled = false;
            worldCtx.drawImage(worldBuffer, 0, 0);
            worldCtx.restore();
        }

        function drawWolfram() {
            wolfBufCtx.fillStyle = getCssVar('--bg');
            wolfBufCtx.fillRect(0,0,512,80);

            const buf = new Uint32Array(wolfImgData.data.buffer);
            const dead = hexToRgb(getCssVar('--bg'));
            const colOn = 0xFFFFFFFF;
            const colOff = (255 << 24) | (dead.b+20 << 16) | (dead.g+20 << 8) | (dead.r+20);
            
            for(let y=0; y<HISTORY_LEN; y++) {
                const row = strip.history[y];
                if(!row) continue;
                for(let x=0; x<512; x++) {
                    const val = row[x];
                    let col;
                    if(y === 0) col = val ? colOn : colOff; 
                    else {
                        const fade = Math.max(0, 255 - (y*3)); 
                        if(val) col = (255 << 24) | (fade << 16) | (fade/1.2 << 8) | 0; 
                        else col = (255<<24) | 0x050505;
                    }
                    buf[y*512 + x] = col;
                }
            }
            wolfBufCtx.putImageData(wolfImgData, 0, 0);

            const lockOnRGB = hexToRgb(getCssVar('--lock-on'));
            const lockOffRGB = hexToRgb(getCssVar('--lock-off'));
            
            // Draw locks overlay
            for(let x=0; x<512; x++) {
                const lock = strip.locks[x];
                if(lock === 1) { 
                    // Green lock
                    // If Ghost Mode, draw semi-transparent so we see simulation underneath
                    wolfBufCtx.fillStyle = strip.ghostMode 
                        ? `rgba(${lockOnRGB.r},${lockOnRGB.g},${lockOnRGB.b}, 0.4)`
                        : `rgb(${lockOnRGB.r},${lockOnRGB.g},${lockOnRGB.b})`;
                        
                    // Draw full height strip for ghost mode, or just top bar for normal
                    const h = strip.ghostMode ? 80 : 2;
                    wolfBufCtx.fillRect(x, 0, 1, h); 
                } else if(lock === 2) { 
                    // Red lock
                    wolfBufCtx.fillStyle = strip.ghostMode 
                        ? `rgba(${lockOffRGB.r},${lockOffRGB.g},${lockOffRGB.b}, 0.4)`
                        : `rgb(${lockOffRGB.r},${lockOffRGB.g},${lockOffRGB.b})`;
                    const h = strip.ghostMode ? 80 : 2;
                    wolfBufCtx.fillRect(x, 0, 1, h);
                }
            }

            if(selectedHistoryIndex > 0) {
                 wolfBufCtx.fillStyle = 'rgba(255, 255, 0, 0.4)';
                 wolfBufCtx.fillRect(0, selectedHistoryIndex, 512, 1);
            }

            wolfCtx.fillStyle = getCssVar('--bg');
            wolfCtx.fillRect(0,0, wolfCvs.width, wolfCvs.height);
            wolfCam.apply(wolfCtx);
            wolfCtx.imageSmoothingEnabled = false;
            wolfCtx.drawImage(wolfBuffer, 0, 0);
            wolfCtx.restore();
        }

        /* --- PRESETS & IO --- */
        let rulePresets = [{name: "Chaos", val: 30}, {name: "Fractal", val: 90}, {name: "Comp", val: 110}, {name: "Flow", val: 184}, {name: "Wall", val: 73}];
        function renderRulePresets() {
            const list = document.getElementById('rulePresetList'); list.innerHTML = '';
            rulePresets.forEach((p, idx) => {
                const item = document.createElement('div'); item.className = 'preset-item';
                item.innerHTML = `<span class="preset-name" onclick="setRule(${p.val})">${p.name} (${p.val})</span><button class="icon-btn del-btn" onclick="deleteRulePreset(${idx})">×</button>`;
                list.appendChild(item);
            });
        }
        function saveRulePreset() { rulePresets.push({ name: document.getElementById('ruleNameInput').value.trim() || "Custom", val: ruleByte }); renderRulePresets(); }
        function deleteRulePreset(idx) { rulePresets.splice(idx, 1); renderRulePresets(); }

        let maskPresets = [{ name: "Conway GoL", data: generateConwayMask() }];
        function generateConwayMask() {
            const mask = new Uint8Array(512);
            for(let i=0; i<512; i++) {
                const center = (i >> 4) & 1; let neighbors = 0;
                for(let bit=0; bit<9; bit++) if(bit !== 4 && ((i >> bit) & 1)) neighbors++;
                if(center === 1) mask[i] = (neighbors === 2 || neighbors === 3) ? 1 : 0; else mask[i] = (neighbors === 3) ? 1 : 0;
            }
            return Array.from(mask);
        }
        function renderMaskPresets() {
            const list = document.getElementById('maskPresetList'); list.innerHTML = '';
            maskPresets.forEach((p, idx) => {
                const item = document.createElement('div'); item.className = 'preset-item';
                item.innerHTML = `<span class="preset-name" onclick="loadMaskPreset(${idx})">${p.name}</span><button class="icon-btn del-btn" onclick="deleteMaskPreset(${idx})">×</button>`;
                list.appendChild(item);
            });
        }
        function saveMaskPreset() { maskPresets.push({ name: document.getElementById('maskNameInput').value.trim() || "Custom", data: Array.from(strip.cells) }); renderMaskPresets(); }
        function loadMaskPreset(idx) {
            strip.loadMask(maskPresets[idx].data);
            if(maskPresets[idx].name.includes("Conway") && !isStripPaused) toggleStripPause();
        }
        function deleteMaskPreset(idx) { maskPresets.splice(idx, 1); renderMaskPresets(); }

        /* --- FILE IO --- */
        function triggerExport() {
            const data = {
                cells: Array.from(strip.cells),
                locks: Array.from(strip.locks),
                rule: ruleByte,
                timestamp: Date.now()
            };
            const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gene_preset_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function triggerImport() {
            document.getElementById('importFile').click();
        }

        function handleFileImport(input) {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    strip.loadData(data);
                    if(data.rule !== undefined) {
                        setRule(data.rule);
                        document.getElementById('ruleInput').value = data.rule;
                    }
                    // Reset file input so same file can be selected again if needed
                    input.value = '';
                } catch(err) {
                    alert("Error parsing JSON file");
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        /* --- UI & INTERACTION --- */
        function buildRuleUI() {
            const grid = document.getElementById('ruleGrid'); grid.innerHTML = '';
            document.getElementById('ruleInput').value = ruleByte;
            for(let i=7; i>=0; i--) {
                const isActive = (ruleByte >> i) & 1;
                const div = document.createElement('div'); div.className = `rule-bit ${isActive ? 'active' : ''}`;
                div.onclick = () => { ruleByte ^= (1 << i); buildRuleUI(); };
                div.innerHTML = `<div class="bit-pattern"><div class="bit-cell ${(i>>2)&1?'on':''}"></div><div class="bit-cell ${(i>>1)&1?'on':''}"></div><div class="bit-cell ${(i)&1?'on':''}"></div></div><div class="bit-val">${isActive}</div>`;
                grid.appendChild(div);
            }
        }
        function setRule(n) { ruleByte = n; buildRuleUI(); }
        function randomizeRule() { setRule(Math.floor(Math.random() * 256)); }
        function setRuleFromInput(val) { setRule(Math.max(0, Math.min(255, parseInt(val)||0))); }
        function randomizeStrip() { strip.seedRandom(parseInt(document.getElementById('stripDensity').value)); }
        function togglePause() { isPaused = !isPaused; document.getElementById('pauseBtn').innerText = isPaused ? "START" : "STOP"; }
        function toggleStripPause() { isStripPaused = !isStripPaused; document.getElementById('pauseStripBtn').innerText = isStripPaused ? "Resume Gene" : "Pause Gene"; }
        document.getElementById('speedRange').addEventListener('input', (e) => { fps = parseInt(e.target.value); document.getElementById('fpsDisplay').innerText = fps + " FPS"; });
        
        function updateHistoryUI() {
            const rawVal = parseInt(document.getElementById('historySlider').value);
            selectedHistoryIndex = (HISTORY_LEN - 1) - rawVal;
            const tooltip = document.getElementById('historyTooltip');
            tooltip.innerText = selectedHistoryIndex === 0 ? "Now" : `G: -${selectedHistoryIndex}`;
            tooltip.style.display = 'block';
            const pct = 100 - (rawVal / (HISTORY_LEN - 1) * 100);
            tooltip.style.top = pct + "%";
            drawWolfram();
        }
        
        document.getElementById('historySlider').addEventListener('mouseup', () => { document.getElementById('historyTooltip').style.display = 'none'; });
        document.getElementById('historySlider').addEventListener('touchend', () => { document.getElementById('historyTooltip').style.display = 'none'; });

        function restoreHistory() {
            if(selectedHistoryIndex < strip.history.length && strip.history[selectedHistoryIndex]) {
                strip.cells.set(strip.history[selectedHistoryIndex]);
                if(!isStripPaused) toggleStripPause();
                drawWolfram();
            }
        }

        /* --- MOUSE EVENTS --- */
        function attachCamEvents(canvas, cam, paintFn, hoverFn) {
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1 : 1;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const wPosBefore = cam.screenToWorld(e.clientX, e.clientY);
                const newZoom = Math.min(cam.maxZoom, Math.max(cam.minZoom, cam.zoom * (1 + delta * 0.1)));
                cam.zoom = newZoom;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const internalX = mouseX * scaleX;
                const internalY = mouseY * scaleY;
                cam.offsetX = internalX - (wPosBefore.x * cam.zoom);
                cam.offsetY = internalY - (wPosBefore.y * cam.zoom);
                cam.constrain(); 
                drawWorld(); drawWolfram();
            }, { passive: false }); // Add passive: false to ensure preventDefault works reliably

            canvas.addEventListener('mousedown', (e) => {
                const canPan = cam.zoom > (cam.minZoom + 0.001);
                if((e.button === 1 || (e.button === 0 && e.code === 'Space')) && canPan) {
                    cam.isDragging = true; cam.lastX = e.clientX; cam.lastY = e.clientY;
                    e.preventDefault();
                } else if(e.button === 0 || e.button === 2) {
                    e.preventDefault();
                    paintFn(e, cam, true);
                }
            });

            window.addEventListener('mousemove', (e) => {
                if(cam.isDragging) {
                    const rect = cam.canvas.getBoundingClientRect();
                    const scaleX = cam.canvas.width / rect.width;
                    const scaleY = cam.canvas.height / rect.height;
                    const dx = (e.clientX - cam.lastX) * scaleX;
                    const dy = (e.clientY - cam.lastY) * scaleY;
                    cam.offsetX += dx; 
                    cam.offsetY += dy;
                    cam.lastX = e.clientX; cam.lastY = e.clientY;
                    cam.constrain(); 
                    drawWorld(); drawWolfram();
                }
            });
            window.addEventListener('mouseup', () => { cam.isDragging = false; });
            
            canvas.addEventListener('mousemove', (e) => {
                if(!cam.isDragging && e.buttons > 0) paintFn(e, cam, false);
                if(hoverFn) hoverFn(e, cam);
            });
        }

        let lastMousePos = {x: -1, y: -1, onWorld: false};

        const paintWorldAction = (e, cam, isStart) => {
            const val = (e.buttons === 2 || (e.buttons === 0 && e.button === 2)) ? 0 : 1;
            
            const p = cam.screenToWorld(e.clientX, e.clientY);
            const x = Math.floor(p.x); const y = Math.floor(p.y);
            const radius = parseInt(document.getElementById('brushSize').value) - 1;
            for(let dy=-radius; dy<=radius; dy++) {
                for(let dx=-radius; dx<=radius; dx++) {
                    const tx = x + dx; const ty = y + dy;
                    if (tx >= 0 && tx < W && ty >= 0 && ty < H) world.data[ty * W + tx] = val;
                }
            }
            drawWorld();
        };

        const updateInspector = () => {
            const {x, y} = lastMousePos;
            if(!lastMousePos.onWorld || x < 0 || x >= W || y < 0 || y >= H) {
                document.getElementById('nbPreview').style.display = 'none'; 
                lastInspIndex = -1; // Reset
                return;
            }

            const index = world.getNeighborhood(x, y);

            // --- OPTIMIZATION START ---
            // If the index hasn't changed, don't redraw the DOM
            if (index === lastInspIndex && document.getElementById('nbPreview').style.display !== 'none') return;
            lastInspIndex = index;
            // --- OPTIMIZATION END ---

            const outcome = strip.getRenderValue(index);

            document.getElementById('nbPreview').style.display = 'flex';
            document.getElementById('inspIndex').innerText = index;
            const outSpan = document.getElementById('inspOutcome');
            outSpan.innerText = outcome ? "LIVES" : "DIES";
            outSpan.style.color = outcome ? "var(--run)" : "var(--stop)";

            const grid = document.getElementById('nbGrid'); grid.innerHTML = '';
            for(let i=8; i>=0; i--) {
                const isOn = (index >> i) & 1;
                const d = document.createElement('div');
                d.className = `nb-cell ${isOn ? 'on' : ''} ${i===4 ? 'center':''}`;
                grid.appendChild(d);
            }
        };

        const hoverWorldAction = (e, cam) => {
            const p = cam.screenToWorld(e.clientX, e.clientY);
            lastMousePos = { x: Math.floor(p.x), y: Math.floor(p.y), onWorld: true };
            updateInspector();
        };

        worldCvs.addEventListener('mouseleave', () => { lastMousePos.onWorld = false; updateInspector(); });

        const paintStripAction = (e, cam, isStart) => {
            const p = cam.screenToWorld(e.clientX, e.clientY);
            const x = Math.floor(p.x);
            if(x >= 0 && x < STRIP_LEN) {
                if(isStart) {
                    if (e.shiftKey) {
                        lockMode = (strip.locks[x] === 1) ? 0 : 1;
                    } else if (e.altKey || e.ctrlKey) {
                        lockMode = (strip.locks[x] === 2) ? 0 : 2;
                    } else if (e.buttons === 1 || e.button === 0) {
                        geneDrawMode = strip.cells[x] ? 0 : 1; 
                    }
                }
                
                if (e.shiftKey) {
                    if (lockMode === 1) { strip.locks[x] = 1; strip.cells[x] = 1; } 
                    else strip.locks[x] = 0;
                } else if (e.altKey || e.ctrlKey) {
                    if (lockMode === 2) { strip.locks[x] = 2; strip.cells[x] = 0; } 
                    else strip.locks[x] = 0;
                } else if ((e.buttons === 1 || e.button === 0) && strip.locks[x] === 0) {
                    strip.cells[x] = geneDrawMode;
                }
                
                strip.history[0][x] = strip.cells[x];
                drawWolfram();
            }
        };

        attachCamEvents(worldCvs, worldCam, paintWorldAction, hoverWorldAction);
        attachCamEvents(wolfCvs, wolfCam, paintStripAction, null);

        /* --- LOOP --- */
        let lastTime = 0;
        function loop(time) {
            if(lastMousePos.onWorld) updateInspector();
            if (!isPaused && time - lastTime > 1000 / fps) {
                world.update(strip);
                geneUpdateCounter++;
                const delay = parseInt(document.getElementById('geneDelayInput').value) || 1;
                if(geneUpdateCounter >= delay) {
                    if(!isStripPaused) { strip.evolve(); document.getElementById('genCount').innerText = "G:" + strip.gen; } 
                    else strip.applyLocks();
                    geneUpdateCounter = 0;
                }
                lastTime = time;
            }
            drawWorld(); drawWolfram();
            requestAnimationFrame(loop);
        }

        setTimeout(resetWorldCam, 100); 
        buildRuleUI(); renderRulePresets(); renderMaskPresets();
        requestAnimationFrame(loop);

    </script>
</body>
</html>