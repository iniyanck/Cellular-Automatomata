<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CELLULAR AUTOMATOMATA V2.1</title>
    <style>
        /* --- VARIABLES --- */
        :root { --bg: #0f172a; --panel: #1e293b; --text: #94a3b8; --text-head: #e2e8f0; --accent: #6366f1; --accent-glow: rgba(99, 102, 241, 0.4); --border: #334155; --run: #10b981; --stop: #f43f5e; --warn: #f97316; --lock-on: #4ade80; --lock-off: #ef4444; --cell-dead: #020617; --cell-alive: #38bdf8; --font-main: 'Segoe UI', 'Roboto', monospace; }
        [data-theme="matrix"] { --bg: #000000; --panel: #0a0a0a; --text: #008f11; --text-head: #00ff41; --accent: #00ff41; --accent-glow: rgba(0, 255, 65, 0.4); --border: #003b00; --run: #00ff41; --stop: #005c00; --warn: #ccff00; --lock-on: #afffaf; --lock-off: #003300; --cell-dead: #000500; --cell-alive: #00ff41; }
        [data-theme="magma"] { --bg: #1a0505; --panel: #2a0a0a; --text: #dcbaba; --text-head: #ffcccc; --accent: #ff4500; --accent-glow: rgba(255, 69, 0, 0.4); --border: #551111; --run: #ff8800; --stop: #880000; --warn: #ffcc00; --lock-on: #ffaa55; --lock-off: #550000; --cell-dead: #110000; --cell-alive: #ff4500; }
        [data-theme="paper"] { --bg: #f8fafc; --panel: #ffffff; --text: #64748b; --text-head: #0f172a; --accent: #2563eb; --accent-glow: rgba(37, 99, 235, 0.2); --border: #cbd5e1; --run: #16a34a; --stop: #dc2626; --warn: #d97706; --lock-on: #15803d; --lock-off: #b91c1c; --cell-dead: #f8fafc; --cell-alive: #1e293b; }

        /* --- GLOBAL & LAYOUT --- */
        * { scrollbar-width: thin; scrollbar-color: var(--border) var(--bg); }
        *::-webkit-scrollbar { width: 10px; height: 10px; }
        *::-webkit-scrollbar-track { background: var(--bg); border-left: 1px solid var(--border); }
        *::-webkit-scrollbar-thumb { background-color: var(--border); border-radius: 5px; border: 2px solid var(--bg); }
        *::-webkit-scrollbar-thumb:hover { background-color: var(--accent); }
        *::-webkit-scrollbar-corner { background: var(--bg); }
        body { font-family: var(--font-main); background: var(--bg); color: var(--text); margin: 0; display: flex; height: 100vh; overflow: hidden; font-size: 13px; }
        .viewport { flex: 1; display: flex; flex-direction: column; border-right: 1px solid var(--border); position: relative; overflow: hidden; }
        .controls { width: 420px; min-width: 420px; background: var(--bg); display: flex; flex-direction: column; overflow-y: auto; box-shadow: -5px 0 15px rgba(0,0,0,0.5); border-left: 1px solid var(--border); z-index: 20; }
        .header { padding: 8px 12px; background: var(--panel); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; z-index: 10; }
        .world-wrapper { flex: 1; background: var(--cell-dead); position: relative; overflow: hidden; width: 100%; height: 100%; }
        canvas { image-rendering: pixelated; position: absolute; left: 0; top: 0; cursor: crosshair; }
        
        /* --- INPUTS: SLIDERS & CHECKBOXES --- */
        input[type="range"] { width: 100%; cursor: pointer; -webkit-appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { background: var(--border); height: 4px; border-radius: 2px; }
        input[type="range"]::-moz-range-track { background: var(--border); height: 4px; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: var(--accent); cursor: pointer; margin-top: -4px; box-shadow: 0 0 5px var(--accent-glow); }
        input[type="range"]::-moz-range-thumb { height: 12px; width: 12px; border-radius: 50%; background: var(--accent); cursor: pointer; border: none; box-shadow: 0 0 5px var(--accent-glow); }
        
        /* Vertical Slider Theming */
        .history-slider-box { width: 20px; height: 100%; display: flex; flex-direction: column; align-items: center; background: var(--panel); border-left: 1px solid var(--border); position: relative; }
        input[type=range][orient=vertical] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 100%; height: 100%; padding: 0; margin: 0; cursor: ns-resize; accent-color: var(--accent); }
        .history-tooltip { position: absolute; right: 25px; background: var(--accent); color: white; font-size: 10px; padding: 2px 4px; border-radius: 3px; pointer-events: none; white-space: nowrap; display: none; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); z-index: 100; }

        /* Custom Checkbox Theming */
        input[type="checkbox"] { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: var(--bg); border: 1px solid var(--border); border-radius: 3px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; vertical-align: text-bottom; position: relative; }
        input[type="checkbox"]:hover { border-color: var(--text); }
        input[type="checkbox"]:checked { background: var(--accent); border-color: var(--accent); }
        input[type="checkbox"]:checked:after { content: ''; width: 4px; height: 8px; border: solid #fff; border-width: 0 2px 2px 0; transform: rotate(45deg); margin-top: -2px; }
        input[type="number"], input[type="text"], select { background: var(--bg); border: 1px solid var(--border); color: var(--text-head); padding: 4px; border-radius: 4px; font-family: monospace; font-size: 11px; }

        /* --- COMPONENTS --- */
        .wolfram-container { display: flex; gap: 0; margin-top: 10px; height: 80px; background: var(--bg); border: 1px solid var(--border); }
        .wolfram-canvas-box { position: relative; flex: 1; height: 100%; overflow: hidden; background: var(--bg); }
        .neighborhood-preview { position: absolute; bottom: 10px; left: 10px; background: rgba(15, 23, 42, 0.85); border: 1px solid var(--border); backdrop-filter: blur(4px); padding: 8px; border-radius: 4px; pointer-events: none; display: none; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); z-index: 50; width: 90px; flex-direction: column; align-items: center; }
        .nb-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; margin-bottom: 5px; }
        .nb-cell { width: 10px; height: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); }
        .nb-cell.on { background: var(--accent); box-shadow: 0 0 4px var(--accent); border-color: var(--accent); }
        .nb-cell.center { border: 1px solid var(--text-head); }
        .control-block { padding: 15px; border-bottom: 1px solid var(--border); background: var(--panel); }
        
        /* --- UI ELEMENTS --- */
        h2 { margin: 0 0 12px 0; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-head); }
        button { background: var(--panel); border: 1px solid var(--border); color: var(--text-head); padding: 4px 10px; cursor: pointer; border-radius: 4px; font-family: inherit; transition: all 0.2s; font-size: 11px; text-transform: uppercase; }
        button:hover { background: var(--border); transform: translateY(-1px); }
        button.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
        button.primary:hover { box-shadow: 0 0 10px var(--accent-glow); background: var(--accent); }
        button.lock-btn { border-color: var(--lock-on); color: var(--lock-on); background: transparent; }
        button.lock-btn:hover { background: rgba(74, 222, 128, 0.1); }
        button.icon-btn { padding: 4px 8px; font-size: 10px; }
        button.del-btn { border-color: var(--stop); color: var(--stop); background: transparent; }
        button.exp-btn { border-color: var(--text); color: var(--text); background: transparent; margin-left: auto; margin-right: 5px; }
        .row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .sub-text { font-size: 10px; color: var(--text); line-height: 1.4; margin-bottom: 10px; opacity: 0.8; }
        .rule-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; margin-top: 15px; }
        .rule-bit { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 6px 2px; background: rgba(255,255,255,0.03); border: 1px solid transparent; border-radius: 4px; }
        .rule-bit.active { border-color: var(--accent); background: var(--accent-glow); }
        .bit-pattern { display: flex; gap: 1px; margin-bottom: 6px; }
        .bit-cell { width: 4px; height: 4px; background: var(--border); }
        .bit-cell.on { background: var(--text); }
        .bit-val { font-size: 10px; color: var(--text); font-weight: bold; }
        .rule-bit.active .bit-val { color: var(--accent); }
        .preset-list { display: flex; flex-direction: column; gap: 4px; margin-top: 10px; max-height: 100px; overflow-y: auto; border: 1px solid var(--border); padding: 4px; border-radius: 4px; background: rgba(0,0,0,0.1); }
        .preset-item { display: flex; align-items: center; background: var(--panel); padding: 4px 8px; border-radius: 3px; border: 1px solid transparent; }
        .preset-item:hover { border-color: var(--accent); }
        .preset-name { cursor: pointer; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .tot-container { display: flex; flex-direction: column; gap: 4px; margin-top: 5px; }
        .tot-row { display: flex; align-items: center; gap: 8px; }
        .tot-label { font-weight: bold; width: 15px; color: var(--accent); font-size: 11px; }
        .tot-bits { display: flex; flex: 1; gap: 2px; justify-content: space-between; }
        .t-btn { flex: 1; text-align: center; background: rgba(255,255,255,0.05); border: 1px solid var(--border); color: var(--text); font-size: 10px; padding: 4px 0; cursor: pointer; border-radius: 3px; user-select: none; }
        .t-btn:hover { border-color: var(--text-head); }
        .t-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 0 5px var(--accent-glow); }
    </style>
</head>
<body>

    <input type="file" id="importFile" accept=".json" style="display:none" onchange="handleFileImport(this)">

    <div class="viewport">
        <div class="header">
            <span style="font-weight:bold; color:var(--accent); font-size:1.1em; letter-spacing:1px;">CELLULAR AUTOMATOMATA V2.2</span>
            <div style="display:flex; gap:10px; align-items: center;">
                <select id="themeSelect" onchange="setTheme(this.value)">
                    <option value="cyber">Theme: Cyber</option>
                    <option value="matrix">Theme: Matrix</option>
                    <option value="magma">Theme: Magma</option>
                    <option value="paper">Theme: Paper</option>
                </select>
                <div style="width:1px; height:20px; background:var(--border)"></div>
                
                <div style="display:flex; align-items:center; gap:5px" title="Paintbrush Size">
                    <span>Brush:</span>
                    <input type="number" id="brushSize" value="1" min="1" max="10" style="width:35px">
                </div>

                <div style="width:1px; height:20px; background:var(--border)"></div>

                <label style="font-size:11px;">
                    <input type="checkbox" id="wrap2dCheck" checked onchange="world.setWrap(this.checked)"> Wrap
                </label>
                <label style="font-size:11px; margin-right:10px;">
                    <input type="checkbox" id="ageCheck" checked onchange="toggleAgeMode(this.checked)"> Show Age 
                </label>
                <button onclick="world.randomize()">RND</button>
                <button onclick="world.clear()">CLR</button>
                <button class="primary" onclick="resetWorldCam()">Fit View</button>
            </div>
        </div>
        
        <div class="world-wrapper" id="worldWrapper" oncontextmenu="return false;">
            <canvas id="worldCanvas" width="600" height="400"></canvas>
            
            <div id="nbPreview" class="neighborhood-preview">
                <div style="font-size:10px; margin-bottom:4px; color:var(--text)">IDX: <span id="inspIndex" style="color:var(--text-head)">0</span></div>
                <div class="nb-grid" id="nbGrid"></div>
                <div style="font-size:10px; color:var(--text)">OUT: <span id="inspOutcome" style="font-weight:bold">?</span></div>
            </div>
        </div>
    </div>

    <div class="controls">
        
        <div class="control-block">
            <div class="row">
                <h2>Simulation</h2>
                <div style="display:flex; gap:10px; align-items: center;">
                    <span id="fpsDisplay" style="font-size:11px; opacity:0.7">30 FPS</span>
                    <button id="pauseBtn" class="primary" onclick="togglePause()">STOP</button>
                </div>
            </div>
            <input type="range" id="speedRange" min="1" max="60" value="30">
        </div>

        <div class="control-block">
            <div class="row">
                <h2>Gene Strip (Mask)</h2>
                <div style="display:flex; align-items:center; gap:10px;">
                    <span id="genCount" style="font-size:11px; font-family:monospace">G:0</span>
                    <button id="pauseStripBtn" style="border-color:var(--warn); color:var(--warn); background:transparent" onclick="toggleStripPause()">Pause Gene</button>
                </div>
            </div>
            
            <div class="sub-text">
                <strong>ZOOM:</strong> Scroll (at cursor) | <strong>PAN:</strong> Middle/Left Drag<br>
                <strong>2D:</strong> Right Click Erase | <strong>GENE:</strong> Click toggles
            </div>
            
            <div class="row" style="margin-top:10px; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px;">
                <div style="display:flex; flex-direction:column; gap:5px; width:100%">
                    <div class="row" style="margin:0">
                        <label style="font-size:11px;" title="Edges connect">
                            <input type="checkbox" id="wrap1dCheck" checked onchange="strip.setWrap(this.checked)"> Wrap
                        </label>
                        <div style="display:flex; align-items:center; gap:5px;">
                            <span style="font-size:10px;">DELAY:</span>
                            <input type="number" id="geneDelayInput" value="1" min="1" max="100" style="width:40px">
                        </div>
                    </div>
                    <div class="row" style="margin:0">
                         <span style="font-size:11px;">Rnd Density:</span>
                         <input type="number" id="stripDensity" min="0" max="100" value="5" style="width:50px">
                    </div>
                    <div class="row" style="margin:0; border-top:1px solid rgba(255,255,255,0.1); padding-top:4px; margin-top:2px;">
                        <label style="font-size:11px; color:var(--accent);" title="Pattern ignores locks, locks only apply to output">
                            <input type="checkbox" id="ghostMaskCheck" onchange="strip.setGhost(this.checked)"> Ghost Mask
                        </label>
                    </div>
                </div>
            </div>

            <div class="row" style="justify-content: flex-end; gap: 5px; flex-wrap:wrap">
                <button onclick="strip.stabilize()" class="lock-btn">Stabilize</button>
                <button onclick="randomizeStrip()">RND</button>
                <button onclick="strip.seedCenter()">CTR</button>
                <button onclick="strip.seedClear()">CLR</button>
                <button onclick="strip.unlockAll()" style="font-size:10px">Unlk</button>
            </div>

            <div class="wolfram-container" oncontextmenu="return false;">
                <div class="wolfram-canvas-box" id="wolfWrapper">
                    <canvas id="wolframCanvas" width="512" height="80"></canvas>
                </div>
                <div class="history-slider-box">
                    <input type="range" orient="vertical" id="historySlider" min="0" max="79" value="79" oninput="updateHistoryUI()">
                    <div id="historyTooltip" class="history-tooltip">0</div>
                </div>
            </div>
            
            <div class="row" style="margin-top:5px; justify-content: flex-end;">
                 <button onclick="restoreHistory()" style="font-size:10px; width:100%">Restore Selected Row</button>
            </div>

            <div style="margin-top: 15px; border-top: 1px solid var(--border); padding-top:10px; background:rgba(255,255,255,0.02); padding:10px; border-radius:4px;">
                <div class="row">
                    <h3 style="margin:0; font-size:11px; color:var(--text); text-transform: uppercase;">Generator: Totalistic</h3>
                    <button onclick="applyTotalistic()" class="primary icon-btn">Apply to Gene</button>
                </div>
                
                <div class="sub-text" style="margin-bottom:5px;">
                    Generates mask based on neighbor counts.
                </div>

                <div class="tot-container">
                    <div class="tot-row">
                        <span class="tot-label">B</span>
                        <div class="tot-bits" id="bornBits"></div>
                    </div>
                    <div class="tot-row">
                        <span class="tot-label">S</span>
                        <div class="tot-bits" id="surviveBits"></div>
                    </div>
                </div>

                <div class="row" style="margin-top:8px; justify-content: flex-start; gap:5px; flex-wrap:wrap;">
                    <button style="font-size:10px" onclick="setTotalistic('3','23')">Conway</button>
                    <button style="font-size:10px" onclick="setTotalistic('36','23')">HighLife</button>
                    <button style="font-size:10px" onclick="setTotalistic('3','12345')">Maze</button>
                    <button style="font-size:10px" onclick="setTotalistic('34','34')">34 Life</button>
                </div>
            </div>
            <div style="margin-top: 15px; border-top: 1px solid var(--border); padding-top:10px;">
                <div class="row">
                    <h3 style="margin:0; font-size:11px; color:var(--text)">Mask IO</h3>
                    <div style="display:flex; gap:5px">
                        <button class="icon-btn" onclick="triggerImport()" title="Import Preset or Full Save">Import</button>
                        <button class="icon-btn" onclick="triggerExportState()" title="Save Full State">Export State</button>
                    </div>
                </div>
                <div class="row" style="margin-top:8px">
                    <h3 style="margin:0; font-size:11px; color:var(--text)">Mask Presets</h3>
                    <div style="display:flex; gap:5px">
                        <input type="text" id="maskNameInput" placeholder="Name" style="width:70px">
                        <button class="icon-btn primary" onclick="saveMaskPreset()">Save</button>
                    </div>
                </div>
                <div id="maskPresetList" class="preset-list"></div>
            </div>
        </div>

        <div class="control-block" style="flex:1">
            <div class="row">
                <h2>Elementary Rule</h2>
                <div style="display:flex; gap:5px">
                    <button onclick="randomizeRule()">RND</button>
                    <input type="number" id="ruleInput" value="30" min="0" max="255" onchange="setRuleFromInput(this.value)">
                </div>
            </div>

            <div class="rule-grid" id="ruleGrid"></div>

            <div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top:15px;">
                <div class="row">
                    <h3 style="margin:0; font-size:11px; color:var(--text)">Rule Presets</h3>
                    <div style="display:flex; gap:5px">
                        <input type="text" id="ruleNameInput" placeholder="Name" style="width:70px">
                        <button class="icon-btn primary" onclick="saveRulePreset()">Save</button>
                    </div>
                </div>
                <div id="rulePresetList" class="preset-list"></div>
            </div>
        </div>
    </div>

    <script>
        /* --- CONFIG --- */
        const W = 600; 
        const H = 400;
        const STRIP_LEN = 512; 
        const HISTORY_LEN = 80; 
        
        /* --- STATE --- */
        let isPaused = false;
        let isStripPaused = false;
        let fps = 30;
        let ruleByte = 30;
        let geneUpdateCounter = 0;
        let selectedHistoryIndex = 0; 
        let geneDrawMode = 1; // 1 = Draw, 0 = Erase
        let lockMode = 0;
        let lastInspIndex = -1;
        let showAge = false;
        let ageLUT = new Uint32Array(256); // Lookup table for colors
        
        /* --- HELPERS --- */
        function getCssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
            const bigint = parseInt(hex, 16);
            return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
        }
        function getPalette() {
            const dead = hexToRgb(getCssVar('--cell-dead'));
            const alive = hexToRgb(getCssVar('--cell-alive'));
            const colDead = (255 << 24) | (dead.b << 16) | (dead.g << 8) | dead.r;
            const colAlive = (255 << 24) | (alive.b << 16) | (alive.g << 8) | alive.r;
            return { colDead, colAlive };
        }
        function updateAgeLUT() {
            const alive = hexToRgb(getCssVar('--cell-alive'));
            const dead = hexToRgb(getCssVar('--cell-dead'));
            
            // Helper to linear interpolate between two values
            const lerp = (start, end, t) => Math.floor(start + (end - start) * t);

            for (let i = 0; i < 256; i++) {
                // If 0, it's dead
                if (i === 0) {
                    ageLUT[0] = (255 << 24) | (dead.b << 16) | (dead.g << 8) | dead.r;
                    continue;
                }

                // Age 1 is freshest (t=0), Age 120 is oldest (t=1)
                // We cap t at 1.0 so it doesn't overshoot
                const maxAge = 120;
                let t = (i - 1) / maxAge; 
                if(t > 1) t = 1;

                // Interpolate r, g, b from Alive -> Dead
                // Note: As t goes 0->1, we go from Alive Color -> Dead Color
                // To keep it visible, we might want to stop slightly before full dead color,
                // but fully fading looks smoother. Let's cap at 80% fade.
                t = t * 0.85; 

                const r = lerp(alive.r, dead.r, t);
                const g = lerp(alive.g, dead.g, t);
                const b = lerp(alive.b, dead.b, t);

                ageLUT[i] = (255 << 24) | (b << 16) | (g << 8) | r;
            }
        }
        function setTheme(themeName) {
            document.documentElement.setAttribute('data-theme', themeName);
            updateAgeLUT();
            drawWorld(); drawWolfram();
        }

        /* --- CAMERA CLASS --- */
        class Camera {
            constructor(canvas, contentW, contentH) {
                this.canvas = canvas;
                this.cW = contentW; this.cH = contentH;
                this.zoom = 1;
                this.offsetX = 0; this.offsetY = 0;
                this.isDragging = false;
                this.lastX = 0; this.lastY = 0;
                this.minZoom = 0.1;
                this.maxZoom = 40;
            }

            resetToFit(mode = 'contain') {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const scaleX = rect.width / this.cW;
                const scaleY = rect.height / this.cH;
                let fitScale;
                
                if(mode === 'cover') {
                    fitScale = Math.max(scaleX, scaleY) * 1.001; 
                } else {
                    fitScale = Math.min(scaleX, scaleY);
                }
                this.zoom = fitScale;
                this.minZoom = fitScale; 
                this.constrain(); 
            }

            screenToWorld(sx, sy) {
                const rect = this.canvas.getBoundingClientRect();
                const cssX = sx - rect.left;
                const cssY = sy - rect.top;
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const internalX = cssX * scaleX;
                const internalY = cssY * scaleY;
                return {
                    x: (internalX - this.offsetX) / this.zoom,
                    y: (internalY - this.offsetY) / this.zoom
                };
            }

            apply(ctx) {
                ctx.save();
                ctx.translate(this.offsetX, this.offsetY);
                ctx.scale(this.zoom, this.zoom);
            }
            
            constrain() {
                const viewW = this.canvas.width;
                const viewH = this.canvas.height;
                const contentW = this.cW * this.zoom;
                const contentH = this.cH * this.zoom;
                
                if (contentW > viewW + 0.1) {
                    if (this.offsetX > 0) this.offsetX = 0;
                    if (this.offsetX < viewW - contentW) this.offsetX = viewW - contentW;
                } else {
                    this.offsetX = (viewW - contentW) / 2;
                }

                if (contentH > viewH + 0.1) {
                    if (this.offsetY > 0) this.offsetY = 0;
                    if (this.offsetY < viewH - contentH) this.offsetY = viewH - contentH;
                } else {
                    this.offsetY = (viewH - contentH) / 2;
                }
            }
        }

        /* --- 1D AUTOMATON --- */
        class Strip {
            constructor() {
                this.cells = new Uint8Array(STRIP_LEN);
                this.next = new Uint8Array(STRIP_LEN);
                this.locks = new Uint8Array(STRIP_LEN); 
                this.history = [];
                this.gen = 0;
                this.wrap = true;
                this.ghostMode = false;
                this.seedCenter();
            }
            setWrap(val) { this.wrap = val; }
            setGhost(val) { this.ghostMode = val; }

            seedCenter() {
                this.cells.fill(0); this.applyLocks();
                // Only seed if center not locked to 0
                if(this.locks[Math.floor(STRIP_LEN / 2)] !== 2) this.cells[Math.floor(STRIP_LEN / 2)] = 1; 
                this.resetHistory();
            }
            seedRandom(densityPercent) {
                this.cells.fill(0);
                for(let i=0; i<STRIP_LEN; i++) {
                    // If hard locked, skip randomization to respect lock
                    if(!this.ghostMode && this.locks[i] !== 0) continue; 
                    if(Math.random() * 100 < densityPercent) this.cells[i] = 1;
                }
                this.applyLocks(); this.resetHistory();
            }
            seedClear() { this.cells.fill(0); this.applyLocks(); this.resetHistory(); }
            
            // Mask Import/Export
            loadData(data) {
                if(data.cells && data.cells.length === STRIP_LEN) {
                    for(let i=0; i<STRIP_LEN; i++) this.cells[i] = data.cells[i];
                }
                if(data.locks && data.locks.length === STRIP_LEN) {
                    for(let i=0; i<STRIP_LEN; i++) this.locks[i] = data.locks[i];
                }
                this.resetHistory();
                drawWolfram();
            }
            
            loadMask(maskData) {
                for(let i=0; i<STRIP_LEN; i++) this.cells[i] = maskData[i] ? 1 : 0;
                this.applyLocks(); this.resetHistory();
            }
            
            stabilize() { this.locks[0] = 2; this.locks[STRIP_LEN-1] = 2; this.applyLocks(); drawWolfram(); }
            unlockAll() { this.locks.fill(0); drawWolfram(); }
            
            // Helper to get effective value for output/display
            getRenderValue(i) {
                if (this.ghostMode) {
                    // In ghost mode, locks override the simulation for display/output purposes
                    if (this.locks[i] === 1) return 1;
                    if (this.locks[i] === 2) return 0;
                }
                return this.cells[i];
            }

            applyLocks() {
                // In Ghost Mode, we do NOT modify this.cells based on locks, 
                // because we want the simulation to flow "under" them.
                // In Normal Mode, locks overwrite this.cells.
                if(!this.ghostMode) {
                    for(let i=0; i<STRIP_LEN; i++) {
                        if(this.locks[i] === 1) this.cells[i] = 1;
                        if(this.locks[i] === 2) this.cells[i] = 0;
                    }
                }
            }
            
            resetHistory() {
                this.history = new Array(HISTORY_LEN).fill(null).map(() => new Uint8Array(STRIP_LEN));
                this.history[0].set(this.cells); // Store raw cells
                this.gen = 0;
            }
            
            evolve() {
                for (let i = 0; i < STRIP_LEN; i++) {
                    // Hard Lock Logic: if locked and NOT ghost, cell is fixed.
                    if (!this.ghostMode) {
                        if (this.locks[i] === 1) { this.next[i] = 1; continue; }
                        if (this.locks[i] === 2) { this.next[i] = 0; continue; }
                    }

                    let leftVal = 0, rightVal = 0;
                    if (this.wrap) {
                        leftVal = this.cells[(i - 1 + STRIP_LEN) % STRIP_LEN];
                        rightVal = this.cells[(i + 1) % STRIP_LEN];
                    } else {
                        const li = i - 1; const ri = i + 1;
                        leftVal = (li < 0) ? 0 : this.cells[li];
                        rightVal = (ri >= STRIP_LEN) ? 0 : this.cells[ri];
                    }
                    const center = this.cells[i];
                    const pattern = (leftVal << 2) | (center << 1) | rightVal;
                    this.next[i] = (ruleByte >> pattern) & 1;
                }
                
                [this.cells, this.next] = [this.next, this.cells];
                
                this.history.pop();
                // We save the raw simulation state to history
                this.history.unshift(new Uint8Array(this.cells));
                this.gen++;
            }
        }

        /* --- 2D WORLD --- */
        class World {
            constructor(w, h) {
                this.w = w; this.h = h;
                this.data = new Uint8Array(w * h);
                this.next = new Uint8Array(w * h);
                this.wrap = true;
                this.randomize();
            }
            setWrap(val) { this.wrap = val; }
            randomize() { for(let i=0; i<this.data.length; i++) this.data[i] = Math.random() > 0.85 ? 1 : 0; }
            clear() { this.data.fill(0); }
            
            getNeighborhood(x, y) {
                let index = 0; let bitPos = 8;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        let ny, nx, val = 0;
                        if (this.wrap) {
                            ny = (y + dy + this.h) % this.h; nx = (x + dx + this.w) % this.w;
                            val = this.data[ny * this.w + nx];
                        } else {
                            ny = y + dy; nx = x + dx;
                            if (ny >= 0 && ny < this.h && nx >= 0 && nx < this.w) val = this.data[ny * this.w + nx];
                        }
                        if (val > 0) index |= (1 << bitPos);
                        bitPos--;
                    }
                }
                return index;
            }
            update(controllerStrip) {
                const d = this.data; const n = this.next;
                const w = this.w; const h = this.h;
                
                const ruleSet = new Uint8Array(512);
                for(let i=0; i<512; i++) {
                    ruleSet[i] = controllerStrip.getRenderValue(i);
                }

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let index = 0; let bitPos = 8;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                let ny, nx, val = 0;
                                if (this.wrap) {
                                    ny = (y + dy + h) % h; nx = (x + dx + w) % w;
                                    val = d[ny * w + nx];
                                } else {
                                    ny = y + dy; nx = x + dx;
                                    if(ny >= 0 && ny < h && nx >= 0 && nx < w) val = d[ny * w + nx];
                                }
                                // CHANGE: Logic check > 0
                                if (val > 0) index |= (1 << bitPos);
                                bitPos--;
                            }
                        }
                        
                        // Result is 1 (Alive) or 0 (Dead) based on the strip
                        const result = ruleSet[index]; 
                        const currentVal = d[y * w + x];

                        if (result === 1) {
                            // CHANGE: Aging Logic
                            // If it was already alive, increment age (cap at 255)
                            if (currentVal > 0 && currentVal < 255) {
                                n[y * w + x] = currentVal + 1;
                            } else {
                                // If it was dead (0) or max age (255), set/keep at 1 or 255
                                n[y * w + x] = currentVal === 0 ? 1 : 255;
                            }
                        } else {
                            n[y * w + x] = 0;
                        }
                    }
                }
                [this.data, this.next] = [this.next, this.data];
            }
        }

        /* --- INIT --- */
        const strip = new Strip();
        const world = new World(W, H);

        /* --- CANVAS & CAMS --- */
        const worldCvs = document.getElementById('worldCanvas');
        const worldCtx = worldCvs.getContext('2d');
        const worldCam = new Camera(worldCvs, W, H);

        const wolfCvs = document.getElementById('wolframCanvas');
        const wolfCtx = wolfCvs.getContext('2d');
        const wolfCam = new Camera(wolfCvs, 512, 80); 

        // Offscreen buffers
        const worldBuffer = document.createElement('canvas'); worldBuffer.width = W; worldBuffer.height = H;
        const worldBufCtx = worldBuffer.getContext('2d');
        const worldImgData = worldBufCtx.createImageData(W, H);

        const wolfBuffer = document.createElement('canvas'); wolfBuffer.width = 512; wolfBuffer.height = 80;
        const wolfBufCtx = wolfBuffer.getContext('2d');
        const wolfImgData = wolfBufCtx.createImageData(512, 80);

        function resetWorldCam() {
            worldCam.resetToFit('cover');
            wolfCam.resetToFit('contain'); 
            drawWorld(); drawWolfram();
        }

        const resizeObserver = new ResizeObserver(() => {
            const wRect = document.getElementById('worldWrapper').getBoundingClientRect();
            worldCvs.width = wRect.width; worldCvs.height = wRect.height;
            
            const wfRect = document.getElementById('wolfWrapper').getBoundingClientRect();
            wolfCvs.width = wfRect.width; wolfCvs.height = wfRect.height;
            
            worldCam.resetToFit('cover'); 
            wolfCam.resetToFit('contain');
            
            drawWorld(); drawWolfram();
        });
        resizeObserver.observe(document.getElementById('worldWrapper'));
        resizeObserver.observe(document.getElementById('wolfWrapper'));

        /* --- RENDER LOGIC --- */
        function drawWorld() {
            const buf = new Uint32Array(worldImgData.data.buffer);
            
            if (showAge) {
                // Use the Pre-calculated Gradient Lookup Table
                for(let i=0; i<world.data.length; i++) {
                    buf[i] = ageLUT[world.data[i]];
                }
            } else {
                // Classic Logic (Binary)
                const { colDead, colAlive } = getPalette();
                // Note: Check > 0 here because data might contain age values even if mode is off
                for(let i=0; i<world.data.length; i++) {
                    buf[i] = world.data[i] > 0 ? colAlive : colDead; 
                }
            }
            
            worldBufCtx.putImageData(worldImgData, 0, 0);

            worldCtx.fillStyle = getCssVar('--cell-dead');
            worldCtx.fillRect(0,0, worldCvs.width, worldCvs.height);
            worldCam.apply(worldCtx);
            worldCtx.imageSmoothingEnabled = false;
            worldCtx.drawImage(worldBuffer, 0, 0);
            worldCtx.restore();
        }

        function toggleAgeMode(val) {
            showAge = val;
            drawWorld();
        }

        function drawWolfram() {
            wolfBufCtx.fillStyle = getCssVar('--bg');
            wolfBufCtx.fillRect(0,0,512,80);

            const buf = new Uint32Array(wolfImgData.data.buffer);
            
            // Get theme colors
            const cAlive = hexToRgb(getCssVar('--cell-alive'));
            const cDead = hexToRgb(getCssVar('--cell-dead')); // Or --bg
            
            // Pre-calculate packed integers for performance
            // Full Alive Color
            const colOn = (255 << 24) | (cAlive.b << 16) | (cAlive.g << 8) | cAlive.r;
            
            // Helper for fading trail colors
            const lerp = (s, e, t) => Math.floor(s + (e - s) * t);

            for(let y=0; y<HISTORY_LEN; y++) {
                const row = strip.history[y];
                if(!row) continue;
                
                // Calculate fade for this row (older = closer to background)
                let t = y / HISTORY_LEN;
                // Cap fade so we can still see history
                t = Math.min(0.8, t); 

                // Calculate "Faded Alive" color for this row
                const r = lerp(cAlive.r, cDead.r, t);
                const g = lerp(cAlive.g, cDead.g, t);
                const b = lerp(cAlive.b, cDead.b, t);
                const colFaded = (255 << 24) | (b << 16) | (g << 8) | r;

                // Calculate "Dead" color (usually just BG, but maybe slightly tinted if desired)
                const colBg = (255 << 24) | (cDead.b << 16) | (cDead.g << 8) | cDead.r;

                for(let x=0; x<512; x++) {
                    const val = row[x];
                    // If it's the current generation (y=0), use full brightness
                    // Otherwise use the faded color
                    if (val) {
                        buf[y*512 + x] = (y === 0) ? colOn : colFaded;
                    } else {
                        buf[y*512 + x] = colBg;
                    }
                }
            }
            wolfBufCtx.putImageData(wolfImgData, 0, 0);

            // ... (Keep the rest of the lock drawing logic the same) ...
            const lockOnRGB = hexToRgb(getCssVar('--lock-on'));
            const lockOffRGB = hexToRgb(getCssVar('--lock-off'));
            
            for(let x=0; x<512; x++) {
                const lock = strip.locks[x];
                if(lock === 1) { 
                    wolfBufCtx.fillStyle = strip.ghostMode 
                        ? `rgba(${lockOnRGB.r},${lockOnRGB.g},${lockOnRGB.b}, 0.4)`
                        : `rgb(${lockOnRGB.r},${lockOnRGB.g},${lockOnRGB.b})`;
                    const h = strip.ghostMode ? 80 : 2;
                    wolfBufCtx.fillRect(x, 0, 1, h); 
                } else if(lock === 2) { 
                    wolfBufCtx.fillStyle = strip.ghostMode 
                        ? `rgba(${lockOffRGB.r},${lockOffRGB.g},${lockOffRGB.b}, 0.4)`
                        : `rgb(${lockOffRGB.r},${lockOffRGB.g},${lockOffRGB.b})`;
                    const h = strip.ghostMode ? 80 : 2;
                    wolfBufCtx.fillRect(x, 0, 1, h);
                }
            }

            if(selectedHistoryIndex > 0) {
                wolfBufCtx.fillStyle = getCssVar('--warn');
                wolfBufCtx.fillRect(0, selectedHistoryIndex, 512, 1);
            }

            wolfCtx.fillStyle = getCssVar('--bg');
            wolfCtx.fillRect(0,0, wolfCvs.width, wolfCvs.height);
            wolfCam.apply(wolfCtx);
            wolfCtx.imageSmoothingEnabled = false;
            wolfCtx.drawImage(wolfBuffer, 0, 0);
            wolfCtx.restore();
        }

        /* --- PRESETS & IO --- */
        let rulePresets = [{name: "Chaos", val: 30}, {name: "Fractal", val: 90}, {name: "Comp", val: 110}, {name: "Flow", val: 184}, {name: "Wall", val: 73}];
        
        function renderRulePresets() {
            const list = document.getElementById('rulePresetList'); list.innerHTML = '';
            rulePresets.forEach((p, idx) => {
                const item = document.createElement('div'); item.className = 'preset-item';
                item.innerHTML = `
                <span class="preset-name" onclick="setRule(${p.val})">${p.name} (${p.val})</span>
                                <button class="icon-btn del-btn" onclick="deleteRulePreset(${idx})" title="Delete">×</button>`;
                list.appendChild(item);
            });
        }
        function saveRulePreset() { rulePresets.push({ name: document.getElementById('ruleNameInput').value.trim() || "Custom", val: ruleByte }); renderRulePresets(); }
        function deleteRulePreset(idx) { rulePresets.splice(idx, 1); renderRulePresets(); }

        let maskPresets = [{ name: "Conway GoL", data: generateConwayMask() }];
        function generateConwayMask() {
            const mask = new Uint8Array(512);
            for(let i=0; i<512; i++) {
                const center = (i >> 4) & 1; let neighbors = 0;
                for(let bit=0; bit<9; bit++) if(bit !== 4 && ((i >> bit) & 1)) neighbors++;
                if(center === 1) mask[i] = (neighbors === 2 || neighbors === 3) ? 1 : 0; else mask[i] = (neighbors === 3) ? 1 : 0;
            }
            return Array.from(mask);
        }
        function renderMaskPresets() {
            const list = document.getElementById('maskPresetList'); list.innerHTML = '';
            maskPresets.forEach((p, idx) => {
                const item = document.createElement('div'); item.className = 'preset-item';
                item.innerHTML = `
                <span class="preset-name" onclick="loadMaskPreset(${idx})">${p.name}</span>
                <button class="icon-btn exp-btn" onclick="exportMaskPreset(${idx})" title="Export Mask">↓</button>
                <button class="icon-btn del-btn" onclick="deleteMaskPreset(${idx})" title="Delete">×</button>`;
                list.appendChild(item);
            });
        }
        function saveMaskPreset() { maskPresets.push({ name: document.getElementById('maskNameInput').value.trim() || "Custom", data: Array.from(strip.cells) }); renderMaskPresets(); }
        function loadMaskPreset(idx) {
            strip.loadMask(maskPresets[idx].data);
            if (!isStripPaused) {
                toggleStripPause();
            }
            strip.resetHistory();
            drawWolfram(); 
        }
        function deleteMaskPreset(idx) { maskPresets.splice(idx, 1); renderMaskPresets(); }
        
        // Export Mask Logic
        function exportMaskPreset(idx) {
            const p = maskPresets[idx];
            const data = { type: 'mask_preset', name: p.name, data: p.data };
            downloadJSON(data, p.name + "_mask");
        }

        /* --- FILE IO UTILS --- */
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Sanitize filename
            a.download = (filename.replace(/[^a-z0-9]/gi, '_').toLowerCase()) + ".json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function triggerExportState() {
            const data = {
                type: 'full_state',
                cells: Array.from(strip.cells),
                locks: Array.from(strip.locks),
                rule: ruleByte,
                timestamp: Date.now()
            };
            downloadJSON(data, "gene_state_" + Date.now());
        }

        function triggerImport() {
            document.getElementById('importFile').click();
        }

        function handleFileImport(input) {
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.type === 'mask_preset') {
                        maskPresets.push({ name: data.name, data: data.data });
                        renderMaskPresets();
                    }
                    input.value = '';
                } catch(err) {
                    alert("Error parsing JSON file");
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }

        /* --- UI & INTERACTION --- */
        function buildRuleUI() {
            const grid = document.getElementById('ruleGrid'); grid.innerHTML = '';
            document.getElementById('ruleInput').value = ruleByte;
            for(let i=7; i>=0; i--) {
                const isActive = (ruleByte >> i) & 1;
                const div = document.createElement('div'); div.className = `rule-bit ${isActive ? 'active' : ''}`;
                div.onclick = () => { ruleByte ^= (1 << i); buildRuleUI(); };
                div.innerHTML = `<div class="bit-pattern"><div class="bit-cell ${(i>>2)&1?'on':''}"></div><div class="bit-cell ${(i>>1)&1?'on':''}"></div><div class="bit-cell ${(i)&1?'on':''}"></div></div><div class="bit-val">${isActive}</div>`;
                grid.appendChild(div);
            }
        }
        function setRule(n) { ruleByte = n; buildRuleUI(); }
        function randomizeRule() { setRule(Math.floor(Math.random() * 256)); }
        function setRuleFromInput(val) { setRule(Math.max(0, Math.min(255, parseInt(val)||0))); }
        function randomizeStrip() { strip.seedRandom(parseInt(document.getElementById('stripDensity').value)); }
        function togglePause() { isPaused = !isPaused; document.getElementById('pauseBtn').innerText = isPaused ? "START" : "STOP"; }
        function toggleStripPause() { isStripPaused = !isStripPaused; document.getElementById('pauseStripBtn').innerText = isStripPaused ? "Resume Gene" : "Pause Gene"; }
        document.getElementById('speedRange').addEventListener('input', (e) => { fps = parseInt(e.target.value); document.getElementById('fpsDisplay').innerText = fps + " FPS"; });
        
        function updateHistoryUI() {
            const rawVal = parseInt(document.getElementById('historySlider').value);
            selectedHistoryIndex = (HISTORY_LEN - 1) - rawVal;
            const tooltip = document.getElementById('historyTooltip');
            tooltip.innerText = selectedHistoryIndex === 0 ? "Now" : `G: -${selectedHistoryIndex}`;
            tooltip.style.display = 'block';
            const pct = 100 - (rawVal / (HISTORY_LEN - 1) * 100);
            tooltip.style.top = pct + "%";
            drawWolfram();
        }
        
        document.getElementById('historySlider').addEventListener('mouseup', () => { document.getElementById('historyTooltip').style.display = 'none'; });
        document.getElementById('historySlider').addEventListener('touchend', () => { document.getElementById('historyTooltip').style.display = 'none'; });

        function restoreHistory() {
            if(selectedHistoryIndex < strip.history.length && strip.history[selectedHistoryIndex]) {
                strip.cells.set(strip.history[selectedHistoryIndex]);
                if(!isStripPaused) toggleStripPause();
                drawWolfram();
            }
        }

        /* --- TOTALISTIC / NEIGHBOR GENERATOR LOGIC --- */
        let ruleBorn = [0,0,0,1,0,0,0,0,0]; // Default B3
        let ruleSurvive = [0,0,1,1,0,0,0,0,0]; // Default S23

        function initTotalisticUI() {
            const createBtns = (arr, id, type) => {
                const container = document.getElementById(id);
                container.innerHTML = '';
                for(let i=0; i<=8; i++) {
                    const btn = document.createElement('div');
                    btn.className = `t-btn ${arr[i] ? 'active' : ''}`;
                    btn.innerText = i;
                    btn.onclick = () => {
                        arr[i] = !arr[i]; // Toggle
                        btn.className = `t-btn ${arr[i] ? 'active' : ''}`;
                    };
                    container.appendChild(btn);
                }
            };
            createBtns(ruleBorn, 'bornBits', 'B');
            createBtns(ruleSurvive, 'surviveBits', 'S');
        }

        function setTotalistic(bStr, sStr) {
            // Reset
            ruleBorn.fill(0); ruleSurvive.fill(0);
            
            // Parse strings (e.g., "3", "23")
            bStr.split('').forEach(c => ruleBorn[parseInt(c)] = 1);
            sStr.split('').forEach(c => ruleSurvive[parseInt(c)] = 1);
            
            initTotalisticUI(); // Refresh UI
            applyTotalistic();  // Auto-apply
        }

        function applyTotalistic() {
            // 1. Pause the gene strip so it doesn't immediately overwrite our work
            if(!isStripPaused) toggleStripPause();

            // 2. Iterate through all 512 possible neighborhood configurations
            for(let i=0; i<STRIP_LEN; i++) {
                
                // Decode the index into 9 bits (Moore Neighborhood)
                // The simulation uses a specific bit order. 
                // usually bit 4 is center, but we just need to separate center from the rest.
                
                const isCenterAlive = (i >> 4) & 1;
                
                let neighborCount = 0;
                for(let bit=0; bit<9; bit++) {
                    if(bit !== 4) { // Exclude center from neighbor count
                        if( (i >> bit) & 1 ) neighborCount++;
                    }
                }

                // 3. Apply Conway-style logic
                let result = 0;
                if(isCenterAlive) {
                    if(ruleSurvive[neighborCount]) result = 1;
                } else {
                    if(ruleBorn[neighborCount]) result = 1;
                }

                // 4. Update the strip (Gene)
                if(strip.ghostMode || strip.locks[i] === 0) {
                     strip.cells[i] = result;
                }
            }

            // 5. Update History & View
            strip.resetHistory();
            drawWolfram();
        }

        /* --- MOUSE EVENTS --- */
        function attachCamEvents(canvas, cam, paintFn, hoverFn) {
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -1 : 1;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const wPosBefore = cam.screenToWorld(e.clientX, e.clientY);
                const newZoom = Math.min(cam.maxZoom, Math.max(cam.minZoom, cam.zoom * (1 + delta * 0.1)));
                cam.zoom = newZoom;
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const internalX = mouseX * scaleX;
                const internalY = mouseY * scaleY;
                cam.offsetX = internalX - (wPosBefore.x * cam.zoom);
                cam.offsetY = internalY - (wPosBefore.y * cam.zoom);
                cam.constrain(); 
                drawWorld(); drawWolfram();
            }, { passive: false }); 

            canvas.addEventListener('mousedown', (e) => {
                if(canvas.id === 'worldCanvas') {
                    document.getElementById('themeSelect').blur();
                }
                const canPan = cam.zoom > (cam.minZoom + 0.001);
                if((e.button === 1 || (e.button === 0 && e.code === 'Space')) && canPan) {
                    cam.isDragging = true; cam.lastX = e.clientX; cam.lastY = e.clientY;
                    e.preventDefault();
                } else if(e.button === 0 || e.button === 2) {
                    e.preventDefault();
                    paintFn(e, cam, true);
                }
            });

            window.addEventListener('mousemove', (e) => {
                if(cam.isDragging) {
                    const rect = cam.canvas.getBoundingClientRect();
                    const scaleX = cam.canvas.width / rect.width;
                    const scaleY = cam.canvas.height / rect.height;
                    const dx = (e.clientX - cam.lastX) * scaleX;
                    const dy = (e.clientY - cam.lastY) * scaleY;
                    cam.offsetX += dx; 
                    cam.offsetY += dy;
                    cam.lastX = e.clientX; cam.lastY = e.clientY;
                    cam.constrain(); 
                    drawWorld(); drawWolfram();
                }
            });
            window.addEventListener('mouseup', () => { cam.isDragging = false; });
            
            canvas.addEventListener('mousemove', (e) => {
                if(!cam.isDragging && e.buttons > 0) paintFn(e, cam, false);
                if(hoverFn) hoverFn(e, cam);
            });
        }

        let lastMousePos = {x: -1, y: -1, onWorld: false};

        const paintWorldAction = (e, cam, isStart) => {
            const val = (e.buttons === 2 || (e.buttons === 0 && e.button === 2)) ? 0 : 1;
            
            const p = cam.screenToWorld(e.clientX, e.clientY);
            const x = Math.floor(p.x); const y = Math.floor(p.y);
            const radius = parseInt(document.getElementById('brushSize').value) - 1;
            for(let dy=-radius; dy<=radius; dy++) {
                for(let dx=-radius; dx<=radius; dx++) {
                    const tx = x + dx; const ty = y + dy;
                    if (tx >= 0 && tx < W && ty >= 0 && ty < H) world.data[ty * W + tx] = val;
                }
            }
            drawWorld();
        };

        const updateInspector = () => {
            const {x, y} = lastMousePos;
            if(!lastMousePos.onWorld || x < 0 || x >= W || y < 0 || y >= H) {
                document.getElementById('nbPreview').style.display = 'none'; 
                lastInspIndex = -1; // Reset
                return;
            }

            const index = world.getNeighborhood(x, y);

            // --- OPTIMIZATION START ---
            if (index === lastInspIndex && document.getElementById('nbPreview').style.display !== 'none') return;
            lastInspIndex = index;
            // --- OPTIMIZATION END ---

            const outcome = strip.getRenderValue(index);

            document.getElementById('nbPreview').style.display = 'flex';
            document.getElementById('inspIndex').innerText = index;
            const outSpan = document.getElementById('inspOutcome');
            outSpan.innerText = outcome ? "LIVES" : "DIES";
            outSpan.style.color = outcome ? "var(--run)" : "var(--stop)";

            const grid = document.getElementById('nbGrid'); grid.innerHTML = '';
            for(let i=8; i>=0; i--) {
                const isOn = (index >> i) & 1;
                const d = document.createElement('div');
                d.className = `nb-cell ${isOn ? 'on' : ''} ${i===4 ? 'center':''}`;
                grid.appendChild(d);
            }
        };

        const hoverWorldAction = (e, cam) => {
            const p = cam.screenToWorld(e.clientX, e.clientY);
            lastMousePos = { x: Math.floor(p.x), y: Math.floor(p.y), onWorld: true };
            updateInspector();
        };

        worldCvs.addEventListener('mouseleave', () => { lastMousePos.onWorld = false; updateInspector(); });

        const paintStripAction = (e, cam, isStart) => {
            const p = cam.screenToWorld(e.clientX, e.clientY);
            const x = Math.floor(p.x);
            if(x >= 0 && x < STRIP_LEN) {
                if(isStart) {
                    if (e.shiftKey) {
                        lockMode = (strip.locks[x] === 1) ? 0 : 1;
                    } else if (e.altKey || e.ctrlKey) {
                        lockMode = (strip.locks[x] === 2) ? 0 : 2;
                    } else if (e.buttons === 1 || e.button === 0) {
                        geneDrawMode = strip.cells[x] ? 0 : 1; 
                    }
                }
                
                if (e.shiftKey) {
                    if (lockMode === 1) { strip.locks[x] = 1; strip.cells[x] = 1; } 
                    else strip.locks[x] = 0;
                } else if (e.altKey || e.ctrlKey) {
                    if (lockMode === 2) { strip.locks[x] = 2; strip.cells[x] = 0; } 
                    else strip.locks[x] = 0;
                } else if ((e.buttons === 1 || e.button === 0) && strip.locks[x] === 0) {
                    strip.cells[x] = geneDrawMode;
                }
                
                strip.history[0][x] = strip.cells[x];
                drawWolfram();
            }
        };

        attachCamEvents(worldCvs, worldCam, paintWorldAction, hoverWorldAction);
        attachCamEvents(wolfCvs, wolfCam, paintStripAction, null);

        /* --- LOOP --- */
        let lastTime = 0;
        function loop(time) {
            if (keys.w || keys.a || keys.s || keys.d) {
                const panSpeed = 10; // Adjust speed here (lower is smoother)
                // Note: divide by cam.zoom if you want speed to stay consistent when zoomed in
                const speed = panSpeed; 

                if (keys.w) worldCam.offsetY += speed;
                if (keys.s) worldCam.offsetY -= speed;
                if (keys.a) worldCam.offsetX += speed;
                if (keys.d) worldCam.offsetX -= speed;
                
                worldCam.constrain();
            }
            if(lastMousePos.onWorld) updateInspector();
            if (!isPaused && time - lastTime > 1000 / fps) {
                world.update(strip);
                geneUpdateCounter++;
                const delay = parseInt(document.getElementById('geneDelayInput').value) || 1;
                if(geneUpdateCounter >= delay) {
                    if(!isStripPaused) { strip.evolve(); document.getElementById('genCount').innerText = "G:" + strip.gen; } 
                    else strip.applyLocks();
                    geneUpdateCounter = 0;
                }
                lastTime = time;
            }
            drawWorld(); drawWolfram();
            requestAnimationFrame(loop);
        }
        /* --- KEYBOARD STATE TRACKING --- */
        const keys = { w: false, a: false, s: false, d: false };

        window.addEventListener('keydown', (e) => {
            // Ignore if typing in an input field
            const tag = document.activeElement.tagName.toLowerCase();
            if (tag === 'input' || tag === 'select' || tag === 'textarea') return;

            // Spacebar (Toggle - instantaneous)
            if (e.code === 'Space') {
                e.preventDefault();
                togglePause();
                return;
            }

            // WASD (State tracking)
            if (e.code === 'KeyW') keys.w = true;
            if (e.code === 'KeyA') keys.a = true;
            if (e.code === 'KeyS') keys.s = true;
            if (e.code === 'KeyD') keys.d = true;
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') keys.w = false;
            if (e.code === 'KeyA') keys.a = false;
            if (e.code === 'KeyS') keys.s = false;
            if (e.code === 'KeyD') keys.d = false;
        });

        setTimeout(resetWorldCam, 100); 
        buildRuleUI(); renderRulePresets(); renderMaskPresets(); initTotalisticUI(); updateAgeLUT();
        requestAnimationFrame(loop);

    </script>
</body>
</html>