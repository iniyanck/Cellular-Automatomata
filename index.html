<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Automaton Engine V3.0</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #f8fafc;
            --muted: #94a3b8;
            --border: #334155;
            --spawn: #3b82f6; /* Blue */
            --kill: #ef4444;  /* Red */
            --run: #22c55e;   /* Green */
            --center-marker: rgba(255, 255, 255, 0.3);
        }

        body {
            font-family: 'Segoe UI', monospace;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- HEADER --- */
        header {
            flex: 0 0 50px;
            padding: 0 20px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        h1 { margin: 0; font-size: 1.1rem; color: var(--spawn); letter-spacing: -0.5px; }

        .global-controls { display: flex; gap: 15px; align-items: center; }
        .control-group {
            display: flex; align-items: center; gap: 8px;
            background: rgba(0,0,0,0.2); padding: 4px 10px; border-radius: 4px;
        }
        input[type="range"] { width: 100px; accent-color: var(--spawn); }
        label { font-size: 0.75rem; color: var(--muted); text-transform: uppercase; font-weight: bold; }

        /* --- LAYOUT --- */
        .workspace {
            display: flex;
            flex: 1;
            height: calc(100vh - 50px);
            overflow: hidden;
        }

        .world-container {
            flex: 1;
            background: #050505;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: crosshair;
        }

        #worldCanvas {
            image-rendering: pixelated;
            box-shadow: 0 0 50px rgba(59, 130, 246, 0.1);
            width: 95%; height: 95%; object-fit: contain; 
        }

        .logic-stack {
            width: 500px;
            background: var(--bg);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 5;
        }

        .stack-header {
            padding: 15px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }

        .stack-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- CARDS --- */
        .rule-card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            position: relative;
            transition: all 0.2s;
        }
        /* Active State Colors */
        .rule-card[data-active="true"] { border-left: 4px solid var(--spawn); }
        .rule-card[data-active="false"] { border-left: 4px solid var(--muted); opacity: 0.6; }

        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 12px; padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .super-io-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .grid-label {
            font-size: 0.65rem; color: var(--muted); text-align: center; 
            margin-bottom: 4px; letter-spacing: 1px; font-weight: bold;
        }

        .canvas-wrapper { display: flex; flex-direction: column; align-items: center; }
        
        .arrow-large { font-size: 20px; color: var(--muted); opacity: 0.5; }

        .physics-canvas {
            border: 1px solid var(--border);
            background: #000;
            width: 90px; height: 90px;
            image-rendering: pixelated;
            cursor: pointer;
        }
        .physics-canvas:hover { border-color: var(--spawn); }

        /* --- SUB RULES --- */
        .sub-col {
            display: flex; flex-direction: column; gap: 8px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        .sub-rule-item {
            display: flex; align-items: center; gap: 10px;
            background: rgba(255,255,255,0.03);
            padding: 8px;
            border-radius: 4px;
            border-left: 2px solid transparent;
        }
        .sub-rule-item[data-active="true"] { border-left-color: var(--spawn); }
        .sub-rule-item[data-active="false"] { border-left-color: var(--muted); opacity: 0.5; }

        .sub-canvas {
            width: 36px; height: 36px;
            border: 1px solid #444;
            background: #000;
            cursor: pointer;
            image-rendering: pixelated;
        }
        .sub-canvas:hover { border-color: #fff; }

        /* --- BUTTONS --- */
        button {
            padding: 4px 10px; border-radius: 4px; border: 1px solid var(--border);
            background: var(--panel); color: var(--text); cursor: pointer;
            font-size: 0.75rem; font-weight: 600;
        }
        button:hover { background: var(--border); }
        
        .btn-primary { background: var(--spawn); border-color: var(--spawn); color: white; }
        .btn-primary:hover { filter: brightness(1.1); }
        
        .btn-danger { color: var(--kill); border-color: rgba(239, 68, 68, 0.3); }
        .btn-danger:hover { background: rgba(239, 68, 68, 0.1); }

        .btn-action { width: 60px; }
        .btn-action.stop { background: rgba(239, 68, 68, 0.2); color: var(--kill); border-color: var(--kill); }
        .btn-action.start { background: rgba(34, 197, 94, 0.2); color: var(--run); border-color: var(--run); }

        .power-btn { 
            background: none; border: none; font-size: 1.2rem; padding: 0 5px; color: var(--muted);
        }
        .power-btn:hover { color: #fff; background: none; }
        .power-btn.on { color: var(--spawn); text-shadow: 0 0 10px rgba(59, 130, 246, 0.4); }

        .tool-row { display: flex; gap: 4px; margin-top: 4px; }

    </style>
</head>
<body>

    <header>
        <h1>Recursive Automaton V3.0</h1>
        
        <div class="global-controls">
            <div class="control-group">
                <label>Speed</label>
                <input type="range" id="speedSlider" min="1" max="60" value="30">
                <span id="fpsDisplay">30</span>
            </div>
            <div class="control-group">
                <button id="globalPauseBtn" class="btn-action stop">STOP</button>
                <button onclick="world.randomize()">RND WORLD</button>
                <button onclick="world.grid.fill(0)">CLEAR</button>
                <button onclick="totalChaos()" class="btn-danger">CHAOS</button>
            </div>
        </div>
    </header>

    <div class="workspace">
        <div class="world-container">
            <canvas id="worldCanvas" width="200" height="120"></canvas>
        </div>

        <div class="logic-stack">
            <div class="stack-header">
                <span style="font-weight:bold; color:var(--muted)">PHYSICS LAWS</span>
                <button class="btn-primary" onclick="addSuperRule()">+ NEW LAW</button>
            </div>
            <div id="rulesContainer" class="stack-scroll-area"></div>
        </div>
    </div>

    <script>
        /* --- CONFIG --- */
        const WORLD_W = 200; 
        const WORLD_H = 120;
        const PHYS_SIZE = 9;
        const SUB_SIZE = 3;

        /* --- DATA STRUCTURES --- */
        class Grid {
            constructor(w, h) {
                this.w = w; this.h = h;
                this.data = new Int8Array(w * h);
                this.next = new Int8Array(w * h);
            }
            fill(val) { this.data.fill(val); }
            randomize(density = 0.5) {
                for(let i=0; i<this.data.length; i++) this.data[i] = Math.random() < density ? 1 : 0;
            }
            get(x, y, wrap = true) {
                if (wrap) { x = (x + this.w) % this.w; y = (y + this.h) % this.h; }
                else if (x < 0 || x >= this.w || y < 0 || y >= this.h) return 0;
                return this.data[y * this.w + x];
            }
            set(x, y, val) {
                if (x >= 0 && x < this.w && y >= 0 && y < this.h) this.data[y * this.w + x] = val;
            }
            swap() {
                let temp = this.data; this.data = this.next; this.next = temp; this.next.fill(0); 
            }
        }

        class SubRule {
            constructor() {
                this.id = Math.random().toString(36).substr(2, 9);
                this.active = true;
                this.input = new Grid(SUB_SIZE, SUB_SIZE);  // Condition
                this.output = new Grid(SUB_SIZE, SUB_SIZE); // Result
            }
        }

        class SuperRule {
            constructor(id) {
                this.id = id;
                this.active = true;
                this.paused = false;
                
                // The "Brain" (Condition) - Evolves based on SubRules
                this.physics = new Grid(PHYS_SIZE, PHYS_SIZE);
                
                // The "Stamp" (Result) - Static output applied to World
                this.output = new Grid(PHYS_SIZE, PHYS_SIZE);
                
                this.subRules = []; 
            }

            // Evolve the Physics Grid (The "Brain")
            stepPhysics() {
                if (!this.active || this.paused) return;

                const g = this.physics;
                // Standard CA Logic: Write to Next, then Swap
                
                for (let py = 0; py < g.h; py++) {
                    for (let px = 0; px < g.w; px++) {
                        
                        this.subRules.forEach(sub => {
                            if(!sub.active) return;
                            
                            // Check Match (Input)
                            let match = true;
                            let hasInput = false;

                            for (let sy = 0; sy < SUB_SIZE; sy++) {
                                for (let sx = 0; sx < SUB_SIZE; sx++) {
                                    const ruleVal = sub.input.get(sx, sy, false);
                                    if (ruleVal === 1) {
                                        hasInput = true;
                                        // Offset relative to current pixel
                                        const ox = sx - 1; 
                                        const oy = sy - 1;
                                        if (g.get(px + ox, py + oy) === 0) {
                                            match = false; break;
                                        }
                                    }
                                }
                                if(!match) break;
                            }

                            // Apply Result (Output)
                            if (match && hasInput) {
                                for (let sy = 0; sy < SUB_SIZE; sy++) {
                                    for (let sx = 0; sx < SUB_SIZE; sx++) {
                                        if (sub.output.get(sx, sy, false) === 1) {
                                            const ox = sx - 1;
                                            const oy = sy - 1;
                                            // Write to NEXT grid
                                            const tx = (px + ox + g.w) % g.w;
                                            const ty = (py + oy + g.h) % g.h;
                                            g.next[ty * g.w + tx] = 1; 
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
                g.swap();
            }
        }

        class Simulation {
            constructor() {
                this.world = new Grid(WORLD_W, WORLD_H);
                this.world.randomize(0.1);
                this.superRules = [];
                this.paused = false;
            }

            addRule() {
                const r = new SuperRule(Date.now());
                // Default: Simple Blinker Logic
                r.subRules.push(new SubRule());
                this.superRules.push(r);
                renderUI();
            }

            step() {
                // 1. Evolve all Physics Grids (The Brains)
                this.superRules.forEach(r => r.stepPhysics());

                if (this.paused) return;

                // 2. Evolve World based on Physics Grids
                const w = this.world;
                const pCenterOffset = Math.floor(PHYS_SIZE / 2);

                for (let i = 0; i < w.data.length; i++) {
                    let wx = i % w.w;
                    let wy = Math.floor(i / w.w);

                    // Check every Super Rule
                    this.superRules.forEach(r => {
                        if (!r.active) return;

                        // Check 9x9 Match: World vs Rule.Physics
                        let match = true;
                        let hasStructure = false;

                        for(let ry = 0; ry < PHYS_SIZE; ry++) {
                            for(let rx = 0; rx < PHYS_SIZE; rx++) {
                                const pVal = r.physics.get(rx, ry, false);
                                if (pVal === 1) {
                                    hasStructure = true;
                                    const ox = rx - pCenterOffset;
                                    const oy = ry - pCenterOffset;
                                    
                                    if (w.get(wx + ox, wy + oy) === 0) {
                                        match = false; break;
                                    }
                                }
                            }
                            if(!match) break;
                        }

                        // If Match found, Stamp Rule.Output onto World.Next
                        if (match && hasStructure) {
                            for(let ry = 0; ry < PHYS_SIZE; ry++) {
                                for(let rx = 0; rx < PHYS_SIZE; rx++) {
                                    if (r.output.get(rx, ry, false) === 1) {
                                        const ox = rx - pCenterOffset;
                                        const oy = ry - pCenterOffset;
                                        const tx = (wx + ox + w.w) % w.w;
                                        const ty = (wy + oy + w.h) % w.h;
                                        w.next[ty * w.w + tx] = 1;
                                    }
                                }
                            }
                        }
                    });
                }
                w.swap();
            }
        }

        /* --- GLOBAL STATE --- */
        const sim = new Simulation();
        
        // Initial Setup
        const r1 = new SuperRule(1);
        r1.physics.set(4, 4, 1); r1.physics.set(3, 4, 1); // Condition: Center + Left
        r1.output.set(4, 4, 1); r1.output.set(5, 4, 1);   // Result: Center + Right (Move Right)
        
        const s1 = new SubRule();
        s1.input.set(1, 1, 1); // If Center...
        s1.output.set(2, 1, 1); // Write Right (Physics glides right)
        r1.subRules.push(s1);
        
        sim.superRules.push(r1);

        /* --- RENDERER --- */
        let fps = 30;
        let lastTime = 0;
        const ctx = document.getElementById('worldCanvas').getContext('2d');

        // Draw Helper
        function drawGrid(ctx, grid, color, showGrid=false) {
            const w = grid.w; const h = grid.h;
            const cvs = ctx.canvas;
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,cvs.width,cvs.height);
            
            const cw = cvs.width / w;
            const ch = cvs.height / h;

            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const val = grid.data[y*w+x];
                    
                    if(showGrid) {
                        ctx.strokeStyle = '#222'; ctx.lineWidth=0.5;
                        ctx.strokeRect(x*cw, y*ch, cw, ch);
                    }

                    if(val === 1) {
                        ctx.fillStyle = color;
                        ctx.fillRect(x*cw, y*ch, cw, ch);
                    }
                    
                    // Center Marker
                    if(showGrid && x === Math.floor(w/2) && y === Math.floor(h/2)) {
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.strokeRect(x*cw+1, y*ch+1, cw-2, ch-2);
                    }
                }
            }
        }

        /* --- INPUT HANDLING --- */
        let isDrawing = false;
        let drawVal = 1;

        function attachInput(canvas, gridGetter, color) {
            if(canvas.getAttribute('data-bound')) return;
            canvas.setAttribute('data-bound', 'true');

            const paint = (e) => {
                const rect = canvas.getBoundingClientRect();
                const g = gridGetter();
                const x = Math.floor((e.clientX - rect.left) / (rect.width/g.w));
                const y = Math.floor((e.clientY - rect.top) / (rect.height/g.h));
                g.set(x, y, drawVal);
                
                // Immediate local redraw
                drawGrid(canvas.getContext('2d'), g, color, true);
            };

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                const g = gridGetter();
                const x = Math.floor((e.clientX - rect.left) / (rect.width/g.w));
                const y = Math.floor((e.clientY - rect.top) / (rect.height/g.h));
                drawVal = g.get(x, y, false) === 1 ? 0 : 1;
                paint(e);
            });
            canvas.addEventListener('mousemove', (e) => { if(isDrawing) paint(e); });
            window.addEventListener('mouseup', () => isDrawing = false);
        }

        attachInput(document.getElementById('worldCanvas'), () => sim.world, '#3b82f6');

        /* --- UI GENERATION --- */
        const container = document.getElementById('rulesContainer');

        function renderUI() {
            // Smart update: Only recreate if counts mismatch, otherwise update classes
            // For simplicity in this demo, we verify ID existence.
            
            sim.superRules.forEach((r, idx) => {
                let card = document.getElementById(`card-${r.id}`);
                
                // CREATE CARD IF MISSING
                if(!card) {
                    card = document.createElement('div');
                    card.id = `card-${r.id}`;
                    card.className = 'rule-card';
                    card.innerHTML = `
                        <div class="card-header">
                            <div style="display:flex; align-items:center; gap:10px;">
                                <button class="power-btn" id="pwr-${r.id}" onclick="toggleActive(${r.id})">⏻</button>
                                <span style="font-weight:bold; font-size:0.9rem">LAW ${idx+1}</span>
                            </div>
                            <div style="display:flex; gap:5px;">
                                <button id="play-${r.id}" class="btn-action stop" onclick="togglePause(${r.id})">STOP</button>
                                <button class="btn-danger" style="width:25px" onclick="removeRule(${r.id})">×</button>
                            </div>
                        </div>

                        <div class="super-io-row">
                            <div class="canvas-wrapper">
                                <div class="grid-label">CONDITION (BRAIN)</div>
                                <canvas id="phys-${r.id}" class="physics-canvas" width="90" height="90"></canvas>
                                <div class="tool-row">
                                    <button onclick="clearGrid(${r.id}, 'phys')">CLR</button>
                                    <button onclick="rndGrid(${r.id}, 'phys')">RND</button>
                                </div>
                            </div>
                            <div class="arrow-large">➜</div>
                            <div class="canvas-wrapper">
                                <div class="grid-label">RESULT (STAMP)</div>
                                <canvas id="out-${r.id}" class="physics-canvas" width="90" height="90"></canvas>
                                <div class="tool-row">
                                    <button onclick="clearGrid(${r.id}, 'out')">CLR</button>
                                    <button onclick="fillGrid(${r.id}, 'out')">FILL</button>
                                </div>
                            </div>
                        </div>

                        <div class="sub-col" id="subs-${r.id}"></div>
                        <button style="width:100%; margin-top:10px; opacity:0.7" onclick="addSub(${r.id})">+ ADD LOGIC</button>
                    `;
                    container.appendChild(card);

                    // Bind Canvases
                    attachInput(document.getElementById(`phys-${r.id}`), () => r.physics, '#3b82f6');
                    attachInput(document.getElementById(`out-${r.id}`), () => r.output, '#22c55e');
                }

                // UPDATE STATE VISUALS
                card.setAttribute('data-active', r.active);
                document.getElementById(`pwr-${r.id}`).className = `power-btn ${r.active ? 'on' : ''}`;
                const playBtn = document.getElementById(`play-${r.id}`);
                playBtn.className = `btn-action ${r.paused ? 'start' : 'stop'}`;
                playBtn.innerText = r.paused ? 'START' : 'STOP';

                // SUB RULES RENDER
                const subContainer = document.getElementById(`subs-${r.id}`);
                
                // Cleanup deleted
                Array.from(subContainer.children).forEach(el => {
                    const sid = el.id.split('-')[1];
                    if(!r.subRules.find(s => s.id == sid)) el.remove();
                });

                r.subRules.forEach(s => {
                    let subEl = document.getElementById(`sub-${s.id}`);
                    if(!subEl) {
                        subEl = document.createElement('div');
                        subEl.id = `sub-${s.id}`;
                        subEl.className = 'sub-rule-item';
                        subEl.innerHTML = `
                            <button class="power-btn" id="spwr-${s.id}" onclick="toggleSub(${r.id}, '${s.id}')" style="font-size:1rem">⏻</button>
                            <canvas id="sin-${s.id}" class="sub-canvas" width="36" height="36"></canvas>
                            <span style="color:#666">➜</span>
                            <canvas id="sout-${s.id}" class="sub-canvas" width="36" height="36"></canvas>
                            <div style="flex:1"></div>
                            <button class="btn-danger" style="padding:2px 6px" onclick="removeSub(${r.id}, '${s.id}')">×</button>
                        `;
                        subContainer.appendChild(subEl);
                        attachInput(document.getElementById(`sin-${s.id}`), () => s.input, '#3b82f6');
                        attachInput(document.getElementById(`sout-${s.id}`), () => s.output, '#3b82f6');
                    }
                    subEl.setAttribute('data-active', s.active);
                    document.getElementById(`spwr-${s.id}`).className = `power-btn ${s.active ? 'on' : ''}`;
                });
            });
            
            // Cleanup deleted Super Rules
            Array.from(container.children).forEach(c => {
                const rid = c.id.split('-')[1];
                if(!sim.superRules.find(r => r.id == rid)) c.remove();
            });
        }

        /* --- INTERACTIONS --- */
        function toggleActive(rid) { const r = sim.superRules.find(x => x.id == rid); r.active = !r.active; renderUI(); }
        function togglePause(rid) { const r = sim.superRules.find(x => x.id == rid); r.paused = !r.paused; renderUI(); }
        function removeRule(rid) { sim.superRules = sim.superRules.filter(x => x.id != rid); renderUI(); }
        
        function clearGrid(rid, type) { 
            const r = sim.superRules.find(x => x.id == rid); 
            if(type === 'phys') r.physics.fill(0); else r.output.fill(0); 
        }
        function rndGrid(rid, type) {
             const r = sim.superRules.find(x => x.id == rid); 
             if(type === 'phys') r.physics.randomize(); 
        }
        function fillGrid(rid, type) {
             const r = sim.superRules.find(x => x.id == rid); 
             if(type === 'out') r.output.fill(1); 
        }

        function addSub(rid) { 
            const r = sim.superRules.find(x => x.id == rid); 
            r.subRules.push(new SubRule()); 
            renderUI(); 
        }
        function removeSub(rid, sid) {
            const r = sim.superRules.find(x => x.id == rid);
            r.subRules = r.subRules.filter(s => s.id != sid);
            renderUI();
        }
        function toggleSub(rid, sid) {
            const r = sim.superRules.find(x => x.id == rid);
            const s = r.subRules.find(x => x.id == sid);
            s.active = !s.active;
            renderUI();
        }
        function addSuperRule() { sim.addRule(); }
        function totalChaos() {
            sim.world.randomize();
            sim.superRules.forEach(r => {
                r.physics.randomize();
                r.output.randomize();
            });
        }

        /* --- LOOP --- */
        document.getElementById('speedSlider').oninput = (e) => { 
            fps = e.target.value; 
            document.getElementById('fpsDisplay').innerText = fps; 
        };

        document.getElementById('globalPauseBtn').onclick = (e) => {
            sim.paused = !sim.paused;
            e.target.innerText = sim.paused ? "START" : "STOP";
            e.target.className = `btn-action ${sim.paused ? 'start' : 'stop'}`;
        };

        function loop(timestamp) {
            if(timestamp - lastTime >= 1000/fps) {
                sim.step();
                lastTime = timestamp;
            }
            drawGrid(ctx, sim.world, '#3b82f6');
            
            // Draw UI Grids
            sim.superRules.forEach(r => {
                const pc = document.getElementById(`phys-${r.id}`);
                if(pc) drawGrid(pc.getContext('2d'), r.physics, r.active ? '#3b82f6' : '#555', true);
                
                const oc = document.getElementById(`out-${r.id}`);
                if(oc) drawGrid(oc.getContext('2d'), r.output, r.active ? '#22c55e' : '#555', true);

                r.subRules.forEach(s => {
                    const sic = document.getElementById(`sin-${s.id}`);
                    const soc = document.getElementById(`sout-${s.id}`);
                    if(sic && soc) {
                        drawGrid(sic.getContext('2d'), s.input, s.active ? '#3b82f6' : '#555', true);
                        drawGrid(soc.getContext('2d'), s.output, s.active ? '#3b82f6' : '#555', true);
                    }
                });
            });

            requestAnimationFrame(loop);
        }

        renderUI();
        requestAnimationFrame(loop);

    </script>
</body>
</html>